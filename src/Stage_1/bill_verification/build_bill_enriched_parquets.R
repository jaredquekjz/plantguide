#!/usr/bin/env Rscript
# Build WorldFlora-enriched parquets for Bill's verification
# Outputs to output/wfo_verification/ to avoid contaminating canonical data
#
# PURPOSE: This script merges WorldFlora WFO taxonomy matches with original datasets,
#          applies deduplication logic when multiple WFO matches exist, and creates
#          enriched parquet files ready for Stage 1 verification.
#
# WORKFLOW:
#   1. Load original dataset (e.g., duke_original.parquet)
#   2. Load WorldFlora WFO match results (e.g., duke_wfo_worldflora.csv)
#   3. Apply multi-criteria ranking to select best WFO match per species
#   4. Merge WFO taxonomy with original data (LEFT JOIN preserves all species)
#   5. Write enriched parquet to wfo_verification directory
#
# DATASETS PROCESSED:
#   - Duke ethnobotany (plant_key as ID)
#   - EIVE ecological indicators (TaxonConcept, case-insensitive join)
#   - Mabberly genera (Genus, genus-level matching)
#   - TRY Enhanced traits (SpeciesName)
#   - AusTraits traits (taxon_name)
#   - TRY Selected traits (AccSpeciesName)

# ========================================================================
# AUTO-DETECTING PATHS (works on Windows/Linux/Mac, any location)
# ========================================================================
get_repo_root <- function() {
  # First check if environment variable is set (from run_all_bill.R)
  env_root <- Sys.getenv("BILL_REPO_ROOT", unset = NA)
  if (!is.na(env_root) && env_root != "") {
    return(normalizePath(env_root))
  }

  # Otherwise detect from script path
  args <- commandArgs(trailingOnly = FALSE)
  file_arg <- grep("^--file=", args, value = TRUE)
  if (length(file_arg) > 0) {
    script_path <- sub("^--file=", "", file_arg[1])
    # Navigate up from script to repo root
    # Scripts are in src/Stage_X/bill_verification/
    repo_root <- normalizePath(file.path(dirname(script_path), "..", "..", ".."))
  } else {
    # Fallback: assume current directory is repo root
    repo_root <- normalizePath(getwd())
  }
  return(repo_root)
}

repo_root <- get_repo_root()
INPUT_DIR <- file.path(repo_root, "input")
INTERMEDIATE_DIR <- file.path(repo_root, "intermediate")
OUTPUT_DIR <- file.path(repo_root, "output")

# Create output directories
dir.create(file.path(OUTPUT_DIR, "wfo_verification"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(OUTPUT_DIR, "stage3"), recursive = TRUE, showWarnings = FALSE)



# ========================================================================
# LIBRARY LOADING AND HELPER FUNCTIONS
# ========================================================================
# Load required libraries
suppressPackageStartupMessages({
  library(arrow)        # For reading/writing Parquet files
  library(dplyr)        # For data manipulation (pipes, joins, filtering)
  library(data.table)   # For fast CSV reading with fread() function
})

# Helper function to log messages with timestamps
# This ensures output is immediately visible (flush.console) during long operations
log_msg <- function(...) {
  cat(..., "\n", sep = "")
  flush.console()
}

# Set up output directory for Bill's verification files
# All WFO-enriched parquets go here to keep them separate from canonical outputs
output_dir <- file.path(OUTPUT_DIR, "wfo_verification")
dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

# ==============================================================================
# 1. DUKE ETHNOBOTANY DATASET
# ==============================================================================
# Duke contains ethnobotanical species with plant_key as unique identifier.
# We merge WorldFlora WFO taxonomy matches with the original dataset.
#
# DUKE SPECIFICS:
#   - Join key: plant_key (already unique, no case normalization needed)
#   - Source name: 'scientific_name' field, fallback to 'taxonomy_taxon'
#   - No case-insensitive join required (plant_key is stable ID)

log_msg("=== Processing Duke dataset ===")

# -------------------------------------------------------
# STEP 1: Load original Duke data and WFO match results
# -------------------------------------------------------
# Load original Duke ethnobotany data (pre-WFO enrichment)
duke_orig <- read_parquet(file.path(INPUT_DIR, "duke_original.parquet"))
log_msg("Loaded Duke original: ", nrow(duke_orig), " rows")

# Load WorldFlora WFO matching results (generated by Python workflow)
# This CSV contains multiple potential matches per species (may include synonyms, fuzzy matches)
duke_wfo <- fread(file.path(output_dir, "duke_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded Duke WFO matches: ", nrow(duke_wfo), " rows")

# -------------------------------------------------------
# STEP 2: Data cleaning - standardize NULL representation
# -------------------------------------------------------
# Clean taxonID: convert empty strings to NA to match Python NULL behavior
# This ensures consistent handling of missing WFO IDs across R and Python
duke_wfo$taxonID[trimws(duke_wfo$taxonID) == ""] <- NA

# -------------------------------------------------------
# STEP 3: Build source name for deduplication ranking
# -------------------------------------------------------
# Build source name for matching priority ranking
# Prioritize 'scientific_name' field, fallback to 'taxonomy_taxon' if empty
# This name will be used to rank match quality (exact name match = best)
duke_wfo$src_name <- duke_wfo$scientific_name
empty_idx <- which(is.na(duke_wfo$src_name) | trimws(duke_wfo$src_name) == "")
if (length(empty_idx) > 0) {
  duke_wfo$src_name[empty_idx] <- duke_wfo$taxonomy_taxon[empty_idx]
}

# ======================================================================
# DEDUPLICATION STRATEGY: Multi-criteria ranking to select best match
# ======================================================================
# When WorldFlora returns multiple WFO matches for a species, we rank them
# by quality and select the best one. Lower rank values = higher priority.
#
# RANKING CRITERIA (applied in order):
#   1. matched_rank: WorldFlora confirmed match (Matched = TRUE)
#   2. taxonid_rank: Has valid WFO taxon ID (non-empty)
#   3. exact_rank: Original name exactly matches WFO scientific name
#   4. genus_rank: Genus of original name matches WFO genus (important for fuzzy)
#   5. new_accepted_rank: WFO record is a current accepted name (not synonym)
#   6. status_rank: taxonomicStatus = "Accepted" in WFO
#   7. subseq_rank: WorldFlora internal subsequence number (tiebreaker)

# -------------------------------------------------------
# Create normalized versions for case-insensitive comparison
# -------------------------------------------------------
duke_wfo$scientific_norm <- tolower(trimws(duke_wfo$scientificName))  # WFO name
duke_wfo$src_norm <- tolower(trimws(duke_wfo$src_name))               # Original name

# -------------------------------------------------------
# RANK 1: Prefer WorldFlora confirmed matches
# -------------------------------------------------------
# Matched column = TRUE means WorldFlora found a confident match
# 0 = matched (best), 1 = not matched (worse)
duke_wfo$matched_rank <- as.integer(!tolower(trimws(duke_wfo$Matched)) %in% c("true", "t", "1", "yes"))

# -------------------------------------------------------
# RANK 2: Prefer matches with valid WFO taxon ID
# -------------------------------------------------------
# Empty or NA taxonID means WFO match failed
# 0 = has taxonID (best), 1 = missing taxonID (worse)
duke_wfo$taxonid_rank <- as.integer(trimws(duke_wfo$taxonID) == "" | is.na(duke_wfo$taxonID))

# -------------------------------------------------------
# RANK 3: Prefer exact name matches
# -------------------------------------------------------
# Exact match = original name identical to WFO scientific name
# 0 = exact match (best), 1 = name differs (worse, could be synonym/fuzzy)
duke_wfo$exact_rank <- as.integer(duke_wfo$scientific_norm != duke_wfo$src_norm)

# -------------------------------------------------------
# RANK 4: Prefer genus matches
# -------------------------------------------------------
# Extract first word (genus) from binomial names
# This is critical for fuzzy matches - genus should at least match
duke_wfo$src_genus <- sapply(strsplit(duke_wfo$src_norm, " "), function(x) x[1])
duke_wfo$scientific_genus <- sapply(strsplit(duke_wfo$scientific_norm, " "), function(x) x[1])
# 0 = genus matches (best), 1 = genus differs (worse, likely wrong match)
duke_wfo$genus_rank <- as.integer(duke_wfo$scientific_genus != duke_wfo$src_genus)

# -------------------------------------------------------
# RANK 5: Prefer current accepted names
# -------------------------------------------------------
# New.accepted = TRUE means this is a recently accepted name (not synonym)
# 0 = accepted (best), 1 = synonym or outdated (worse)
duke_wfo$new_accepted_rank <- as.integer(!tolower(trimws(duke_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))

# -------------------------------------------------------
# RANK 6: Prefer "Accepted" taxonomic status
# -------------------------------------------------------
# taxonomicStatus field in WFO indicates if name is accepted or synonym
# IMPORTANT: Case-INSENSITIVE comparison to match pandas behavior (canonical line 153)
# 0 = "Accepted" (best), 1 = "Synonym" or other (worse)
duke_wfo$status_rank <- as.integer(tolower(trimws(duke_wfo$taxonomicStatus)) != "accepted")

# -------------------------------------------------------
# RANK 7: Tiebreaker using WorldFlora subsequence number
# -------------------------------------------------------
# Subseq is WorldFlora's internal ordering for disambiguation
# Lower Subseq = higher confidence, NAs pushed to end (9999999)
duke_wfo$subseq_rank <- suppressWarnings(as.numeric(duke_wfo$Subseq))
duke_wfo$subseq_rank[is.na(duke_wfo$subseq_rank)] <- 9999999  # Push NAs to end

# -------------------------------------------------------
# STEP 4: Apply ranking and deduplicate
# -------------------------------------------------------
# Sort by all ranks (lower = better), then keep first row per plant_key
# Note: plant_key is already a unique ID, no case normalization needed for Duke
duke_wfo_sorted <- duke_wfo %>%
  arrange(plant_key, matched_rank, taxonid_rank, exact_rank, genus_rank,
          new_accepted_rank, status_rank, subseq_rank) %>%
  group_by(plant_key) %>%
  slice(1) %>%  # Keep first (best) match per plant_key
  ungroup()

# -------------------------------------------------------
# STEP 5: Standardize column names and select WFO fields
# -------------------------------------------------------
# Rename WFO columns with 'wfo_' prefix for clarity
# Keep only necessary WFO taxonomy fields for downstream analysis
duke_wfo_clean <- duke_wfo_sorted %>%
  select(
    plant_key,                                  # Original Duke identifier (join key)
    wf_spec_name = spec.name,                   # WorldFlora species name
    wfo_taxon_id = taxonID,                     # WFO Plant List taxon ID (unique identifier)
    wfo_scientific_name = scientificName,       # WFO accepted scientific name
    wfo_taxonomic_status = taxonomicStatus,     # Taxonomic status (Accepted/Synonym)
    wfo_accepted_nameusage_id = acceptedNameUsageID,  # If synonym, ID of accepted name
    wfo_new_accepted = New.accepted,            # Flag: is this a newly accepted name?
    wfo_original_status = Old.status,           # Original WFO status before updates
    wfo_original_id = Old.ID,                   # Original WFO ID before updates
    wfo_original_name = Old.name,               # Original WFO name before updates
    wfo_matched = Matched,                      # Flag: did WorldFlora find a match?
    wfo_unique = Unique,                        # Flag: was the match unique?
    wfo_fuzzy = Fuzzy,                          # Flag: was fuzzy matching used?
    wfo_fuzzy_distance = Fuzzy.dist             # Fuzzy match distance score (lower = better)
  )

# -------------------------------------------------------
# STEP 6: Merge WFO taxonomy with original Duke data
# -------------------------------------------------------
# LEFT JOIN ensures all Duke species are retained, even if no WFO match
# Species without WFO match will have NA in wfo_* columns
duke_enriched <- duke_orig %>%
  left_join(duke_wfo_clean, by = "plant_key")

# -------------------------------------------------------
# STEP 7: Write enriched parquet
# -------------------------------------------------------
# Write enriched parquet to Bill's verification directory
log_msg("Writing Duke enriched parquet...")
write_parquet(duke_enriched, file.path(output_dir, "duke_worldflora_enriched.parquet"), compression = "snappy")
log_msg("Duke complete: ", nrow(duke_enriched), " rows\n")

# ==============================================================================
# 2. EIVE (Ellenberg Indicator Values for Europe)
# ==============================================================================
# EIVE provides ecological indicator values (moisture, nutrients, light, etc.)
# Key difference from Duke: Uses TaxonConcept field, requires case-insensitive join
#
# EIVE SPECIFICS:
#   - Join key: TaxonConcept (case-insensitive, normalized to lowercase)
#   - Source name: 'TaxonConcept' field
#   - CRITICAL: Case variations exist (e.g., "Abies alba" vs "abies alba")
#   - Must create normalized join key BEFORE deduplication

log_msg("=== Processing EIVE dataset ===")

# Load original EIVE data (European ecological indicator values)
eive_orig <- read_parquet(file.path(INPUT_DIR, "eive_original.parquet"))
log_msg("Loaded EIVE original: ", nrow(eive_orig), " rows")

eive_wfo <- fread(file.path(output_dir, "eive_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded EIVE WFO matches: ", nrow(eive_wfo), " rows")

# Clean taxonID: convert empty strings to NA (match Python NULL behavior)
eive_wfo$taxonID[trimws(eive_wfo$taxonID) == ""] <- NA

# Build source name from TaxonConcept field (EIVEs taxon name column)
eive_wfo$src_name <- eive_wfo$TaxonConcept

# Ranking logic
eive_wfo$scientific_norm <- tolower(trimws(eive_wfo$scientificName))
eive_wfo$src_norm <- tolower(trimws(eive_wfo$src_name))
eive_wfo$matched_rank <- as.integer(!tolower(trimws(eive_wfo$Matched)) %in% c("true", "t", "1", "yes"))
eive_wfo$taxonid_rank <- as.integer(trimws(eive_wfo$taxonID) == "" | is.na(eive_wfo$taxonID))
eive_wfo$exact_rank <- as.integer(eive_wfo$scientific_norm != eive_wfo$src_norm)

eive_wfo$src_genus <- sapply(strsplit(eive_wfo$src_norm, " "), function(x) x[1])
eive_wfo$scientific_genus <- sapply(strsplit(eive_wfo$scientific_norm, " "), function(x) x[1])
eive_wfo$genus_rank <- as.integer(eive_wfo$scientific_genus != eive_wfo$src_genus)

eive_wfo$new_accepted_rank <- as.integer(!tolower(trimws(eive_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))
# IMPORTANT: EIVE canonical fixed to case-INSENSITIVE (2025-11-06 bug fix)
eive_wfo$status_rank <- as.integer(tolower(trimws(eive_wfo$taxonomicStatus)) != "accepted")
eive_wfo$subseq_rank <- suppressWarnings(as.numeric(eive_wfo$Subseq))
eive_wfo$subseq_rank[is.na(eive_wfo$subseq_rank)] <- 9999999

# -------------------------------------------------------
# CRITICAL: Create normalized join key BEFORE deduplication
# -------------------------------------------------------
# EIVE has case variations in TaxonConcept (e.g., "Abies alba" vs "abies alba")
# Without normalization, "Abies alba" and "abies alba" would be treated as different species
# This would create false duplicates in the final dataset
eive_wfo$join_key_normalized <- tolower(trimws(eive_wfo$TaxonConcept))

# -------------------------------------------------------
# Apply ranking and deduplicate using normalized key
# -------------------------------------------------------
# Group by normalized taxon name (case-insensitive) instead of raw TaxonConcept
# This ensures "Abies alba" and "abies alba" are treated as the same species
eive_wfo_sorted <- eive_wfo %>%
  arrange(join_key_normalized, matched_rank, taxonid_rank, exact_rank, genus_rank,
          new_accepted_rank, status_rank, subseq_rank) %>%
  group_by(join_key_normalized) %>%
  slice(1) %>%  # Keep first (best) match per normalized taxon
  ungroup()

# Rename columns (keep join_key_normalized for merging)
eive_wfo_clean <- eive_wfo_sorted %>%
  select(
    TaxonConcept,
    join_key_normalized,
    wf_spec_name = spec.name,
    wfo_taxon_id = taxonID,
    wfo_scientific_name = scientificName,
    wfo_taxonomic_status = taxonomicStatus,
    wfo_accepted_nameusage_id = acceptedNameUsageID,
    wfo_new_accepted = New.accepted,
    wfo_original_status = Old.status,
    wfo_original_id = Old.ID,
    wfo_original_name = Old.name,
    wfo_matched = Matched,
    wfo_unique = Unique,
    wfo_fuzzy = Fuzzy,
    wfo_fuzzy_distance = Fuzzy.dist
  )

# -------------------------------------------------------
# Merge with original EIVE data using normalized keys
# -------------------------------------------------------
# CRITICAL: Must normalize original data join key for case-insensitive matching
# This ensures we join "Abies alba" in original data to "abies alba" in WFO data
eive_orig$join_key_normalized <- tolower(trimws(eive_orig$TaxonConcept))

# LEFT JOIN preserves all EIVE species, adding WFO taxonomy where matches exist
eive_enriched <- eive_orig %>%
  left_join(eive_wfo_clean %>% select(-TaxonConcept), by = "join_key_normalized") %>%
  select(-join_key_normalized) %>%  # Remove temporary join key
  # Convert empty strings to NA to match canonical Python NULL behavior
  mutate(across(where(is.character), ~na_if(., "")))

log_msg("Writing EIVE enriched parquet...")
write_parquet(eive_enriched, file.path(output_dir, "eive_worldflora_enriched.parquet"), compression = "snappy")
log_msg("EIVE complete: ", nrow(eive_enriched), " rows\n")

# ==============================================================================
# 3. MABBERLY (Plant Genera Reference)
# ==============================================================================
# Mabberly's Plant-Book: genus-level taxonomy reference
# Key difference: Matches at GENUS level only, not species level

log_msg("=== Processing Mabberly dataset ===")
mab_orig <- read_parquet(file.path(INPUT_DIR, "mabberly_original.parquet"))
log_msg("Loaded Mabberly original: ", nrow(mab_orig), " rows")

mab_wfo <- fread(file.path(output_dir, "mabberly_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded Mabberly WFO matches: ", nrow(mab_wfo), " rows")

# Convert empty string taxonID to NA (match Python behavior)
mab_wfo$taxonID[trimws(mab_wfo$taxonID) == ""] <- NA

# Build source name
mab_wfo$src_name <- mab_wfo$Genus

# Ranking logic
mab_wfo$scientific_norm <- tolower(trimws(mab_wfo$scientificName))
mab_wfo$src_norm <- tolower(trimws(mab_wfo$src_name))
mab_wfo$matched_rank <- as.integer(!tolower(trimws(mab_wfo$Matched)) %in% c("true", "t", "1", "yes"))
mab_wfo$taxonid_rank <- as.integer(trimws(mab_wfo$taxonID) == "" | is.na(mab_wfo$taxonID))
mab_wfo$exact_rank <- as.integer(mab_wfo$scientific_norm != mab_wfo$src_norm)

# For genus matching, genus rank is just whether the first word matches the genus
mab_wfo$scientific_genus <- sapply(strsplit(mab_wfo$scientific_norm, " "), function(x) x[1])
mab_wfo$genus_rank <- as.integer(mab_wfo$scientific_genus != mab_wfo$src_norm)

mab_wfo$new_accepted_rank <- as.integer(!tolower(trimws(mab_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))
# IMPORTANT: Mabberly uses pandas - case-INSENSITIVE comparison (canonical line 471)
mab_wfo$status_rank <- as.integer(tolower(trimws(mab_wfo$taxonomicStatus)) != "accepted")
mab_wfo$subseq_rank <- suppressWarnings(as.numeric(mab_wfo$Subseq))
mab_wfo$subseq_rank[is.na(mab_wfo$subseq_rank)] <- 9999999

# Create normalized join key BEFORE deduplication
mab_wfo$join_key_normalized <- tolower(trimws(mab_wfo$Genus))

mab_wfo_sorted <- mab_wfo %>%
  arrange(join_key_normalized, matched_rank, taxonid_rank, exact_rank, genus_rank,
          new_accepted_rank, status_rank, subseq_rank) %>%
  group_by(join_key_normalized) %>%
  slice(1) %>%
  ungroup()

# Rename columns (keep join_key_normalized for merging)
mab_wfo_clean <- mab_wfo_sorted %>%
  select(
    Genus,
    join_key_normalized,
    wf_spec_name = spec.name,
    wfo_taxon_id = taxonID,
    wfo_scientific_name = scientificName,
    wfo_taxonomic_status = taxonomicStatus,
    wfo_accepted_nameusage_id = acceptedNameUsageID,
    wfo_new_accepted = New.accepted,
    wfo_original_status = Old.status,
    wfo_original_id = Old.ID,
    wfo_original_name = Old.name,
    wfo_matched = Matched,
    wfo_unique = Unique,
    wfo_fuzzy = Fuzzy,
    wfo_fuzzy_distance = Fuzzy.dist
  )

# Merge with normalized keys (case-insensitive, whitespace-trimmed)
mab_orig$join_key_normalized <- tolower(trimws(mab_orig$Genus))

mab_enriched <- mab_orig %>%
  left_join(mab_wfo_clean %>% select(-Genus), by = "join_key_normalized") %>%
  select(-join_key_normalized)

log_msg("Writing Mabberly enriched parquet...")
write_parquet(mab_enriched, file.path(output_dir, "mabberly_worldflora_enriched.parquet"), compression = "uncompressed")
log_msg("Mabberly complete: ", nrow(mab_enriched), " rows\n")

# ==============================================================================
# 4. TRY ENHANCED (Trait Database)
# ==============================================================================
# TRY database: global plant functional traits (leaf area, height, SLA, etc.)
# Uses 'SpeciesName' field, one of the largest datasets (~46K species)

log_msg("=== Processing TRY Enhanced dataset ===")
try_orig <- read_parquet(file.path(INPUT_DIR, "tryenhanced_species_original.parquet"))
log_msg("Loaded TRY Enhanced original: ", nrow(try_orig), " rows")

try_wfo <- fread(file.path(output_dir, "tryenhanced_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded TRY Enhanced WFO matches: ", nrow(try_wfo), " rows")

# Convert empty string taxonID to NA (match Python behavior)
try_wfo$taxonID[trimws(try_wfo$taxonID) == ""] <- NA

# Build source name
try_wfo$src_name <- try_wfo$SpeciesName

# Ranking logic
try_wfo$scientific_norm <- tolower(trimws(try_wfo$scientificName))
try_wfo$src_norm <- tolower(trimws(try_wfo$src_name))
try_wfo$matched_rank <- as.integer(!tolower(trimws(try_wfo$Matched)) %in% c("true", "t", "1", "yes"))
try_wfo$taxonid_rank <- as.integer(trimws(try_wfo$taxonID) == "" | is.na(try_wfo$taxonID))
try_wfo$exact_rank <- as.integer(try_wfo$scientific_norm != try_wfo$src_norm)

try_wfo$src_genus <- sapply(strsplit(try_wfo$src_norm, " "), function(x) x[1])
try_wfo$scientific_genus <- sapply(strsplit(try_wfo$scientific_norm, " "), function(x) x[1])
try_wfo$genus_rank <- as.integer(try_wfo$scientific_genus != try_wfo$src_genus)

try_wfo$new_accepted_rank <- as.integer(!tolower(trimws(try_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))
# IMPORTANT: TRY Enhanced canonical fixed to case-INSENSITIVE (2025-11-06 bug fix)
try_wfo$status_rank <- as.integer(tolower(trimws(try_wfo$taxonomicStatus)) != "accepted")
try_wfo$subseq_rank <- suppressWarnings(as.numeric(try_wfo$Subseq))
try_wfo$subseq_rank[is.na(try_wfo$subseq_rank)] <- 9999999

# Create normalized join key BEFORE deduplication
try_wfo$join_key_normalized <- tolower(trimws(try_wfo$SpeciesName))

try_wfo_sorted <- try_wfo %>%
  arrange(join_key_normalized, matched_rank, taxonid_rank, exact_rank, genus_rank,
          new_accepted_rank, status_rank, subseq_rank) %>%
  group_by(join_key_normalized) %>%
  slice(1) %>%
  ungroup()

# Rename columns (keep join_key_normalized for merging)
try_wfo_clean <- try_wfo_sorted %>%
  select(
    SpeciesName,
    join_key_normalized,
    wf_spec_name = spec.name,
    wfo_taxon_id = taxonID,
    wfo_scientific_name = scientificName,
    wfo_taxonomic_status = taxonomicStatus,
    wfo_accepted_nameusage_id = acceptedNameUsageID,
    wfo_new_accepted = New.accepted,
    wfo_original_status = Old.status,
    wfo_original_id = Old.ID,
    wfo_original_name = Old.name,
    wfo_matched = Matched,
    wfo_unique = Unique,
    wfo_fuzzy = Fuzzy,
    wfo_fuzzy_distance = Fuzzy.dist
  )

# Merge with normalized keys (case-insensitive, whitespace-trimmed)
try_orig$join_key_normalized <- tolower(trimws(try_orig$`Species name standardized against TPL`))

try_enriched <- try_orig %>%
  left_join(try_wfo_clean %>% select(-SpeciesName), by = "join_key_normalized") %>%
  select(-join_key_normalized) %>%
  # Convert empty strings to NA to match canonical NULL behavior
  mutate(across(where(is.character), ~na_if(., "")))

log_msg("Writing TRY Enhanced enriched parquet...")
write_parquet(try_enriched, file.path(output_dir, "tryenhanced_worldflora_enriched.parquet"), compression = "snappy")
log_msg("TRY Enhanced complete: ", nrow(try_enriched), " rows\n")

# ==============================================================================
# 5. AUSTRAITS TRAITS (Australian Plant Traits)
# ==============================================================================
# AusTraits: comprehensive Australian plant trait database
# Uses 'taxon_name' field from the traits parquet (long format with measurements)
#
# AUSTRAITS SPECIFICS:
#   - Join key: taxon_name (case-insensitive, normalized to lowercase)
#   - Source name: 'taxon_name' field
#   - Data format: Long format (multiple rows per species, one per trait measurement)

log_msg("=== Processing AusTraits Traits dataset ===")

# -------------------------------------------------------
# STEP 1: Load original AusTraits data and WFO matches
# -------------------------------------------------------
# Load AusTraits traits data (long format with trait measurements)
# NOTE: Using INPUT_DIR to match auto-detect pattern
# File is austraits_traits.parquet (directly in INPUT_DIR, not in subdirectory)
aus_traits_orig <- read_parquet(file.path(INPUT_DIR, "austraits_traits.parquet"))
log_msg("Loaded AusTraits traits original: ", nrow(aus_traits_orig), " rows")

aus_wfo <- fread(file.path(output_dir, "austraits_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded AusTraits WFO matches: ", nrow(aus_wfo), " rows")

# Convert empty string taxonID to NA (match Python behavior)
aus_wfo$taxonID[trimws(aus_wfo$taxonID) == ""] <- NA

# Build source name
aus_wfo$src_name <- aus_wfo$taxon_name

# Ranking logic
aus_wfo$scientific_norm <- tolower(trimws(aus_wfo$scientificName))
aus_wfo$src_norm <- tolower(trimws(aus_wfo$src_name))
aus_wfo$matched_rank <- as.integer(!tolower(trimws(aus_wfo$Matched)) %in% c("true", "t", "1", "yes"))
aus_wfo$taxonid_rank <- as.integer(trimws(aus_wfo$taxonID) == "" | is.na(aus_wfo$taxonID))
aus_wfo$exact_rank <- as.integer(aus_wfo$scientific_norm != aus_wfo$src_norm)

aus_wfo$src_genus <- sapply(strsplit(aus_wfo$src_norm, " "), function(x) x[1])
aus_wfo$scientific_genus <- sapply(strsplit(aus_wfo$scientific_norm, " "), function(x) x[1])
aus_wfo$genus_rank <- as.integer(aus_wfo$scientific_genus != aus_wfo$src_genus)

aus_wfo$new_accepted_rank <- as.integer(!tolower(trimws(aus_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))
# IMPORTANT: AusTraits uses pandas - case-INSENSITIVE comparison (canonical line 640)
aus_wfo$status_rank <- as.integer(tolower(trimws(aus_wfo$taxonomicStatus)) != "accepted")
aus_wfo$subseq_rank <- suppressWarnings(as.numeric(aus_wfo$Subseq))
aus_wfo$subseq_rank[is.na(aus_wfo$subseq_rank)] <- 9999999

# Create normalized join key BEFORE deduplication
aus_wfo$join_key_normalized <- tolower(trimws(aus_wfo$taxon_name))

aus_wfo_sorted <- aus_wfo %>%
  arrange(join_key_normalized, matched_rank, taxonid_rank, exact_rank, genus_rank,
          new_accepted_rank, status_rank, subseq_rank) %>%
  group_by(join_key_normalized) %>%
  slice(1) %>%
  ungroup()

# Rename columns (keep join_key_normalized for merging)
aus_wfo_clean <- aus_wfo_sorted %>%
  select(
    taxon_name,
    join_key_normalized,
    wf_spec_name = spec.name,
    wfo_taxon_id = taxonID,
    wfo_scientific_name = scientificName,
    wfo_taxonomic_status = taxonomicStatus,
    wfo_accepted_nameusage_id = acceptedNameUsageID,
    wfo_new_accepted = New.accepted,
    wfo_original_status = Old.status,
    wfo_original_id = Old.ID,
    wfo_original_name = Old.name,
    wfo_matched = Matched,
    wfo_unique = Unique,
    wfo_fuzzy = Fuzzy,
    wfo_fuzzy_distance = Fuzzy.dist
  )

# Merge with normalized keys (case-insensitive, whitespace-trimmed)
aus_traits_orig$join_key_normalized <- tolower(trimws(aus_traits_orig$taxon_name))

aus_traits_enriched <- aus_traits_orig %>%
  left_join(aus_wfo_clean %>% select(-taxon_name), by = "join_key_normalized") %>%
  select(-join_key_normalized)

log_msg("Writing AusTraits traits enriched parquet...")
write_parquet(aus_traits_enriched, file.path(output_dir, "austraits_traits_worldflora_enriched.parquet"), compression = "snappy")
log_msg("AusTraits traits complete: ", nrow(aus_traits_enriched), " rows")
log_msg("  (Note: Contains both trait measurements and WFO taxonomy for all AusTraits species)\n")

# ==============================================================================
# 6. TRY SELECTED TRAITS (Curated Trait Subset)
# ==============================================================================
# TRY Selected: curated subset of TRY database with selected traits
# Uses 'AccSpeciesName' field (accepted species name)

log_msg("=== Processing TRY Selected Traits dataset ===")
try_sel_orig <- read_parquet(file.path(INPUT_DIR, "try_selected_traits.parquet"))
log_msg("Loaded TRY Selected Traits original: ", nrow(try_sel_orig), " rows")

try_sel_wfo <- fread(file.path(output_dir, "try_selected_traits_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded TRY Selected Traits WFO matches: ", nrow(try_sel_wfo), " rows")

# Convert empty string taxonID to NA (match Python behavior)
try_sel_wfo$taxonID[trimws(try_sel_wfo$taxonID) == ""] <- NA

# Build source name (use AccSpeciesName)
try_sel_wfo$src_name <- try_sel_wfo$AccSpeciesName

# Ranking logic
try_sel_wfo$scientific_norm <- tolower(trimws(try_sel_wfo$scientificName))
try_sel_wfo$src_norm <- tolower(trimws(try_sel_wfo$src_name))
try_sel_wfo$matched_rank <- as.integer(!tolower(trimws(try_sel_wfo$Matched)) %in% c("true", "t", "1", "yes"))
try_sel_wfo$taxonid_rank <- as.integer(trimws(try_sel_wfo$taxonID) == "" | is.na(try_sel_wfo$taxonID))
try_sel_wfo$exact_rank <- as.integer(try_sel_wfo$scientific_norm != try_sel_wfo$src_norm)

try_sel_wfo$src_genus <- sapply(strsplit(try_sel_wfo$src_norm, " "), function(x) x[1])
try_sel_wfo$scientific_genus <- sapply(strsplit(try_sel_wfo$scientific_norm, " "), function(x) x[1])
try_sel_wfo$genus_rank <- as.integer(try_sel_wfo$scientific_genus != try_sel_wfo$src_genus)

try_sel_wfo$new_accepted_rank <- as.integer(!tolower(trimws(try_sel_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))
try_sel_wfo$status_rank <- as.integer(tolower(trimws(try_sel_wfo$taxonomicStatus)) != "accepted")
try_sel_wfo$subseq_rank <- suppressWarnings(as.numeric(try_sel_wfo$Subseq))
try_sel_wfo$subseq_rank[is.na(try_sel_wfo$subseq_rank)] <- 9999999

# Create normalized join key BEFORE deduplication
try_sel_wfo$join_key_normalized <- tolower(trimws(try_sel_wfo$AccSpeciesName))

try_sel_wfo_sorted <- try_sel_wfo %>%
  arrange(join_key_normalized, matched_rank, taxonid_rank, exact_rank, genus_rank,
          new_accepted_rank, status_rank, subseq_rank) %>%
  group_by(join_key_normalized) %>%
  slice(1) %>%
  ungroup()

# Rename columns (keep join_key_normalized for merging)
try_sel_wfo_clean <- try_sel_wfo_sorted %>%
  select(
    AccSpeciesName,
    join_key_normalized,
    wf_spec_name = spec.name,
    wfo_taxon_id = taxonID,
    wfo_scientific_name = scientificName,
    wfo_taxonomic_status = taxonomicStatus,
    wfo_accepted_nameusage_id = acceptedNameUsageID,
    wfo_new_accepted = New.accepted,
    wfo_original_status = Old.status,
    wfo_original_id = Old.ID,
    wfo_original_name = Old.name,
    wfo_matched = Matched,
    wfo_unique = Unique,
    wfo_fuzzy = Fuzzy,
    wfo_fuzzy_distance = Fuzzy.dist
  )

# Merge with normalized keys (case-insensitive, whitespace-trimmed)
try_sel_orig$join_key_normalized <- tolower(trimws(try_sel_orig$AccSpeciesName))

try_sel_enriched <- try_sel_orig %>%
  left_join(try_sel_wfo_clean %>% select(-AccSpeciesName), by = "join_key_normalized") %>%
  select(-join_key_normalized) %>%
  # Convert empty strings to NA to match canonical NULL behavior
  mutate(across(where(is.character), ~na_if(., "")))

log_msg("Writing TRY Selected Traits enriched parquet...")
write_parquet(try_sel_enriched, file.path(output_dir, "try_selected_traits_worldflora_enriched.parquet"), compression = "snappy")
log_msg("TRY Selected Traits complete: ", nrow(try_sel_enriched), " rows\n")

# ==============================================================================
# 7. GBIF OCCURRENCE DATA (Large streaming dataset)
# ==============================================================================
# GBIF: Global Biodiversity Information Facility occurrence database
# Uses Arrow streaming to process 70M records without loading into memory
#
# GBIF SPECIFICS:
#   - Join key: scientificName (case-insensitive, normalized to lowercase)
#   - Source name: 'scientificName' field
#   - Data format: Occurrence records with coordinates and metadata
#   - File size: ~5.4GB with 70M+ rows

log_msg("=== Processing GBIF Occurrence dataset ===")

# -------------------------------------------------------
# STEP 1: Load WFO matches (small file, can load into memory)
# -------------------------------------------------------
gbif_wfo <- fread(file.path(output_dir, "gbif_occurrence_wfo_worldflora.csv"), data.table = FALSE)
log_msg("Loaded GBIF WFO matches: ", nrow(gbif_wfo), " rows")

# Convert empty string taxonID to NA (match Python behavior)
gbif_wfo$taxonID[trimws(gbif_wfo$taxonID) == ""] <- NA

# Build source name and normalized key for deduplication
gbif_wfo$src_name <- gbif_wfo$scientificName
gbif_wfo$src_norm <- tolower(trimws(gbif_wfo$src_name))
gbif_wfo$scientific_norm <- tolower(trimws(gbif_wfo$scientificName))

# Deduplication logic (same as Python canonical)
gbif_wfo$genus_rank <- 0  # GBIF doesn't have genus matching
gbif_wfo$new_accepted_rank <- as.integer(!tolower(trimws(gbif_wfo$New.accepted)) %in% c("true", "t", "1", "yes"))
gbif_wfo$status_rank <- as.integer(tolower(trimws(gbif_wfo$taxonomicStatus)) != "accepted")
gbif_wfo$subseq_rank <- suppressWarnings(as.numeric(gbif_wfo$Subseq))
gbif_wfo$subseq_rank[is.na(gbif_wfo$subseq_rank)] <- 9999999

# Create normalized join key BEFORE deduplication
gbif_wfo$join_key_normalized <- tolower(trimws(gbif_wfo$scientificName))

# Deduplicate matches: keep best match per scientificName
gbif_wfo_dedup <- gbif_wfo %>%
  group_by(join_key_normalized) %>%
  arrange(genus_rank, new_accepted_rank, status_rank, subseq_rank, .by_group = TRUE) %>%
  slice(1) %>%
  ungroup()

# Rename columns to WFO standard naming
gbif_wfo_clean <- gbif_wfo_dedup %>%
  select(
    scientificName,
    join_key_normalized,
    wf_spec_name = spec.name,
    wfo_taxon_id = taxonID,
    wfo_scientific_name = scientificName.1,
    wfo_taxonomic_status = taxonomicStatus,
    wfo_accepted_nameusage_id = acceptedNameUsageID,
    wfo_new_accepted = New.accepted,
    wfo_original_status = Old.status,
    wfo_original_id = Old.ID,
    wfo_original_name = Old.name,
    wfo_matched = Matched,
    wfo_unique = Unique,
    wfo_fuzzy = Fuzzy,
    wfo_fuzzy_distance = Fuzzy.dist
  )

# -------------------------------------------------------
# STEP 2: Stream GBIF original data and merge with WFO
# -------------------------------------------------------
# Use Arrow to stream the large GBIF file without loading into memory
log_msg("Streaming GBIF original data (5.4GB, 70M+ rows)...")

# Open GBIF as Arrow dataset
gbif_dataset <- open_dataset(file.path(INPUT_DIR, "gbif_occurrence_plantae.parquet"))

# Add normalized join key and merge with WFO matches
# Arrow will handle this efficiently without loading entire file
gbif_enriched <- gbif_dataset %>%
  mutate(join_key_normalized = tolower(trimws(scientificName))) %>%
  left_join(
    arrow_table(gbif_wfo_clean %>% select(-scientificName)),
    by = "join_key_normalized"
  ) %>%
  select(-join_key_normalized) %>%
  compute()  # Materialize the result

log_msg("Writing GBIF enriched parquet...")
write_parquet(gbif_enriched, file.path(output_dir, "gbif_occurrence_plantae_worldflora_enriched.parquet"), compression = "snappy")
log_msg("GBIF complete: ", nrow(gbif_enriched), " rows")
log_msg("  (Note: Large file with occurrence records and WFO taxonomy)\n")

log_msg("=== All enriched parquets created successfully ===")
log_msg("Output directory: ", output_dir)
