# Stage 4.2: Guild Compatibility Framework

## Critical Discovery: Pairwise Scoring is Insufficient

### The Problem

Initial implementation computed pairwise compatibility scores and averaged them for guilds. **This approach fundamentally fails** to capture guild-level ecological dynamics.

**Test case demonstrates failure:**

**Bad Guild** (5 Acacia species, 40 shared pathogenic fungi):
- Pairwise average score: **0.266**
- Shared pathogens on 3-5 plants: Ganoderma (5/5), Armillaria (4/5), Meliola (5/5)
- Ecological reality: Disaster waiting to happen (guild-wide disease outbreak)

**Good Guild** (Taxonomically diverse, minimal overlap):
- Pairwise average score: **0.298**
- Shared pathogens: Only 5 fungi, appearing on 2-3 plants each
- Ecological reality: Low disease transmission risk

**Difference: Only 0.032** - System cannot distinguish good from bad guilds!

### Why Pairwise Averaging Fails

Pairwise averaging misses the critical guild-level vulnerability: **shared susceptibility**.

**Example:**
```
Scenario A: Pathogen X on 1/5 plants (isolated case)
  → Affects 4 pairwise scores
  → Risk: Low (contained to one plant)

Scenario B: Pathogen X on 5/5 plants (complete overlap)
  → Affects 10 pairwise scores with similar Jaccard ratios
  → Risk: CATASTROPHIC (one outbreak destroys entire guild)

Pairwise averaging treats these identically!
```

**Guild-level effects ignored:**
- ✗ Shared vulnerabilities (pathogen can jump across all plants)
- ✗ Biological control benefits (predators from Plant B control pests on Plant A)
- ✗ Network synergies (all plants connected by mycorrhizal fungi)
- ✗ Second-order trophic effects (Plant A attracts pests → Plant B attracts predators of those pests)

---

## New Approach: Guild-Level Overlap Scoring

### Core Concept

**Overlap** = organisms shared across multiple plants in the guild

**Key insight**: If all plants share the same vulnerability, one disease/pest outbreak can destroy the entire guild. Conversely, if plants attract predators of each other's pests, this creates beneficial biological control networks.

### Framework Structure

**Two-component scoring for balanced [-1, +1] range:**

```
NEGATIVE FACTORS (Shared Vulnerabilities)
  - Pathogenic fungi overlap
  - Herbivore overlap
  - Non-fungal pathogen overlap
  → Aggregate to negative_risk_score [0, 1]

POSITIVE FACTORS (Beneficial Interactions)
  - Herbivore control (specific predators + specific fungi + general fungi)
  - Pathogen control (specific antagonists + general mycoparasites)
  - Shared beneficial fungi (mycorrhizae + endophytes + saprotrophs)
  - Taxonomic diversity
  → Aggregate to positive_benefit_score [0, 1]

FINAL SCORE
  guild_score = positive_benefit_score - negative_risk_score
  Range: [-1, +1]

  -1.0 = Maximum risk, no benefits (catastrophic)
  +1.0 = Maximum benefits, no risks (excellent)
```

This structure ensures:
- Equal reachability of +1 and -1
- Clear separation of risks vs benefits
- Intuitive interpretation

---

## NEGATIVE FACTORS (Shared Vulnerabilities)

### Component N1: Pathogenic Fungi Overlap (40% of negative)

**Critical Factor** - Shared pathogenic fungi create guild-wide disease risk.

**Logic**: Each shared fungus is a vulnerability. Worst case: all fungi attack all plants.

**Formula:**
```python
pathogen_overlap_raw = 0

for fungus, plant_count in shared_pathogenic_fungi.items():
    if plant_count < 2:
        continue  # Not shared

    overlap_ratio = plant_count / total_plants

    # Quadratic penalty: complete overlap is catastrophic
    # 2/5 plants = 0.4² = 0.16
    # 5/5 plants = 1.0² = 1.00 (6× worse)
    overlap_penalty = overlap_ratio ** 2

    # Host specificity weighting
    if is_host_specific(fungus):
        severity = 1.0  # Worse: can't escape via diversity
    else:
        severity = 0.6

    pathogen_overlap_raw += overlap_penalty * severity

# Normalize to [0, 1] using tanh
# Scaling factor chosen so 5-10 shared pathogens → ~0.5, 40+ → ~1.0
pathogen_fungi_norm = tanh(pathogen_overlap_raw / 8.0)
```

**Example - Bad Guild:**
```
Ganoderma on 5/5 plants: (1.0)² × 1.0 = 1.00
Armillaria on 4/5 plants: (0.8)² × 1.0 = 0.64
Meliola on 5/5 plants: (1.0)² × 0.6 = 0.60
... × 37 more fungi
Total raw: 15-25
Normalized: tanh(3.1) = 0.996 (catastrophic)
```

**Example - Good Guild:**
```
5 fungi, each on 2/5 plants: (0.4)² × 0.6 = 0.096 each
Total raw: 5 × 0.096 = 0.48
Normalized: tanh(0.06) = 0.060 (minimal)
```

---

### Component N2: Herbivore Overlap (30% of negative)

**Logic**: Shared herbivores create pest outbreak risk, similar to pathogens.

**Formula:**
```python
herbivore_overlap_raw = 0

for herbivore, plant_count in shared_herbivores.items():
    if plant_count < 2:
        continue

    overlap_ratio = plant_count / total_plants
    overlap_penalty = overlap_ratio ** 2

    herbivore_overlap_raw += overlap_penalty * 0.5

# Scaling: 5 shared herbivores → ~0.3, 20+ → ~0.9
herbivore_norm = tanh(herbivore_overlap_raw / 4.0)
```

---

### Component N3: Non-Fungal Pathogen Overlap (30% of negative)

**Logic**: Bacterial/viral/oomycete pathogens, similar to fungal pathogens but often less data.

**Formula:**
```python
pathogen_other_raw = 0

for pathogen, plant_count in shared_pathogens.items():
    if plant_count < 2:
        continue

    overlap_ratio = plant_count / total_plants
    overlap_penalty = overlap_ratio ** 2

    pathogen_other_raw += overlap_penalty * 0.7

# Scaling: fewer non-fungal pathogens typically
pathogen_other_norm = tanh(pathogen_other_raw / 3.0)
```

---

### Negative Factor Aggregation

```python
negative_risk_score = (
    0.40 * pathogen_fungi_norm +
    0.30 * herbivore_norm +
    0.30 * pathogen_other_norm
)
# Result: [0, 1] where 0 = no shared vulnerabilities, 1 = catastrophic overlap
```

**Rationale for weights:**
- Pathogenic fungi (40%): Most catastrophic - disease outbreaks can destroy entire guilds
- Herbivores (30%): Significant but less deadly than pathogens
- Other pathogens (30%): Important but often less data available

---

## POSITIVE FACTORS (Beneficial Interactions)

### Component P1: Herbivore Control Benefits (30% of positive)

**Second-Order Trophic Effect** - Plant A attracts herbivore H, Plant B provides biological control → pest suppression benefit.

**Three mechanisms:**
1. **Specific animal predators**: Plant B attracts animal predators that eat Plant A's specific herbivores (from GloBI predator-prey data)
2. **Specific entomopathogenic fungi**: Plant B hosts fungi that parasitize Plant A's specific herbivores (from GloBI fungus-insect data)
3. **General entomopathogenic fungi**: Plant B hosts entomopathogenic fungi + Plant A has herbivores → broad-spectrum biocontrol (from FungalTraits)

**Data sources:**
- `plant_organism_profiles.parquet`: herbivores per plant, flower_visitors
- `plant_fungal_guilds_hybrid.parquet`: entomopathogenic_fungi (FungalTraits)
- `herbivore_predators.parquet`: specific predator-prey relationships (GloBI)
- `insect_fungal_parasites.parquet`: specific herbivore→fungal parasite relationships (GloBI) **NEW**

**Formula:**
```python
herbivore_control_raw = 0

# For each pair of plants in guild
for plant_a in guild:
    for plant_b in guild:
        if plant_a == plant_b:
            continue

        herbivores_a = profiles[plant_a]['herbivores']

        # Mechanism 1: Specific animal predators (weight 1.0)
        visitors_b = profiles[plant_b]['flower_visitors']

        for herbivore in herbivores_a:
            if herbivore not in herbivore_predators:
                continue

            predators_of_herbivore = herbivore_predators[herbivore]['predators']
            beneficial_predators = visitors_b.intersection(predators_of_herbivore)
            herbivore_control_raw += len(beneficial_predators) * 1.0  # Specific match

        # Mechanism 2: Specific entomopathogenic fungi (weight 1.0) **NEW**
        entomopathogenic_b = fungal[plant_b]['entomopathogenic_fungi']

        for herbivore in herbivores_a:
            if herbivore not in insect_fungal_parasites:
                continue

            parasites_of_herbivore = insect_fungal_parasites[herbivore]['entomopathogenic_fungi']
            beneficial_fungi = entomopathogenic_b.intersection(parasites_of_herbivore)
            herbivore_control_raw += len(beneficial_fungi) * 1.0  # Specific match

        # Mechanism 3: General entomopathogenic fungi (weight 0.3)
        if len(herbivores_a) > 0 and len(entomopathogenic_b) > 0:
            # General biocontrol benefit proportional to diversity
            herbivore_control_raw += len(entomopathogenic_b) * 0.3  # General benefit

# Normalize by guild size
max_pairs = total_plants * (total_plants - 1)
herbivore_control_norm = tanh(herbivore_control_raw / max_pairs * 10) if max_pairs > 0 else 0
```

**Example:**
- Plant A (tomato) has herbivore: *Spodoptera litura* (armyworm)
- Plant B (buckwheat):
  - Attracts: *Cotesia glomerata* (parasitoid wasp) → **+1.0** (specific predator match)
  - Hosts: *Beauveria bassiana* (known parasite of *Spodoptera*) → **+1.0** (specific fungus match)
  - Hosts: *Metarhizium anisopliae* (general entomopathogen) → **+0.3** (general benefit)
- Total benefit from this pair: **2.3**

**Coverage from GloBI data:**
- 1,212 herbivores with known fungal parasites
- 4,779 unique entomopathogenic fungi
- Key pests covered: spider mites (*Metarhizium*), mealybugs (*Neozygites*), armyworms (*Beauveria*), aphids (*Zoophthora*)

---

### Component P2: Pathogen Control Benefits (30% of positive)

**Second-Order Disease Control** - Plant A has pathogen X, Plant B provides biocontrol fungi → disease suppression benefit.

**Two mechanisms:**
1. **Specific antagonist matches**: Plant B hosts fungi that specifically attack Plant A's pathogens (from GloBI data)
2. **General mycoparasites**: Plant B hosts mycoparasite fungi + Plant A has pathogenic fungi → broad-spectrum biocontrol

**Data sources:**
- `plant_fungal_guilds_hybrid.parquet`: pathogenic_fungi, mycoparasite_fungi per plant
- `pathogen_antagonists.parquet`: specific antagonist-pathogen relationships (from GloBI)

**Formula:**
```python
pathogen_control_raw = 0

for plant_a in guild:
    for plant_b in guild:
        if plant_a == plant_b:
            continue

        pathogens_a = fungal[plant_a]['pathogenic_fungi']
        mycoparasites_b = fungal[plant_b]['mycoparasite_fungi']

        # Mechanism 1: Specific antagonist matches (higher value)
        for pathogen in pathogens_a:
            if pathogen not in pathogen_antagonists:
                continue

            antagonists_of_pathogen = pathogen_antagonists[pathogen]['antagonists']

            # Check if Plant B's mycoparasites match this pathogen's known antagonists
            beneficial_antagonists = mycoparasites_b.intersection(antagonists_of_pathogen)
            pathogen_control_raw += len(beneficial_antagonists) * 1.0  # Specific match = full weight

        # Mechanism 2: General mycoparasite benefit (lower value)
        if len(pathogens_a) > 0 and len(mycoparasites_b) > 0:
            # General biocontrol benefit proportional to diversity
            pathogen_control_raw += len(mycoparasites_b) * 0.3  # General benefit = reduced weight

# Normalize by guild size
pathogen_control_norm = tanh(pathogen_control_raw / max_pairs * 10) if max_pairs > 0 else 0
```

**Example:**
- Plant A (rose) has pathogen: *Podosphaera pannosa* (powdery mildew)
- Plant B hosts: *Ampelomyces quisqualis* (mycoparasite) → specific antagonist of *Podosphaera* → **+1.0**
- Plant B also hosts: *Trichoderma harzianum*, *Clonostachys rosea* (general mycoparasites) → **+0.6** (2 × 0.3)
- Total benefit from this pair: 1.6

---

### Component P3: Shared Beneficial Fungi (25% of positive)

**Positive Overlap** - Unlike pathogens, shared beneficial fungi strengthen guild resilience and nutrient cycling.

**Four categories of beneficial fungi:**
1. **AMF (Arbuscular mycorrhizal fungi)**: Nutrient exchange, drought tolerance
2. **EMF (Ectomycorrhizal fungi)**: Nutrient exchange, pathogen protection
3. **Endophytic fungi**: Disease suppression, stress tolerance, growth promotion
4. **Saprotrophic fungi**: Nutrient cycling, organic matter decomposition, soil health

**Data source:**
- `plant_fungal_guilds_hybrid.parquet`: amf_fungi, emf_fungi, endophytic_fungi, saprotrophic_fungi

**Formula:**
```python
# Count shared beneficial fungi across all 4 categories
shared_beneficial = count_shared_organisms(
    fungal,
    'amf_fungi',
    'emf_fungi',
    'endophytic_fungi',
    'saprotrophic_fungi'
)

network_raw = 0
for fungus, plant_count in shared_beneficial.items():
    if plant_count >= 2:  # Shared across 2+ plants
        coverage = plant_count / total_plants
        # Higher coverage = stronger network
        network_raw += coverage

# Coverage bonus: what % of plants have beneficial fungi?
plants_with_beneficial = sum(1 for _, plant in fungal.iterrows()
    if (plant['amf_fungi'] is not None and len(plant['amf_fungi']) > 0) or
       (plant['emf_fungi'] is not None and len(plant['emf_fungi']) > 0) or
       (plant['endophytic_fungi'] is not None and len(plant['endophytic_fungi']) > 0) or
       (plant['saprotrophic_fungi'] is not None and len(plant['saprotrophic_fungi']) > 0))

coverage_ratio = plants_with_beneficial / total_plants

# Combined score
beneficial_fungi_raw = network_raw * 0.6 + coverage_ratio * 0.4

# Normalize to [0, 1]
# Scaling: 3-5 shared beneficial fungi → ~0.5, 10+ → ~0.9
beneficial_fungi_norm = tanh(beneficial_fungi_raw / 3.0)
```

**Example:**
- Guild has 3 shared AMF fungi covering 4/5 plants → network_raw += 0.8 + 0.8 + 0.8 = 2.4
- Guild has 2 shared endophytes covering 3/5 plants → network_raw += 0.6 + 0.6 = 1.2
- All 5 plants have beneficial fungi → coverage_ratio = 1.0
- Score: (3.6 × 0.6 + 1.0 × 0.4) / 3.0 = 0.85 → tanh(0.85) = 0.69

---

### Component P4: Taxonomic Diversity (15% of positive)

**Logic**: Different plant families = lower disease transmission risk, higher functional diversity, greater ecological resilience.

**Formula:**
```python
# Count unique families
families = set(plant['family'] for plant in guild)
family_diversity = len(families) / total_plants

# Shannon diversity index (more sophisticated)
from collections import Counter
family_counts = Counter(plant['family'] for plant in guild)
H = 0
for count in family_counts.values():
    p = count / total_plants
    if p > 0:
        H -= p * log(p)

H_max = log(total_plants) if total_plants > 1 else 1
shannon_normalized = H / H_max if H_max > 0 else 0

# Combined diversity score
diversity_norm = family_diversity * 0.6 + shannon_normalized * 0.4
# Already in [0, 1]
```

**Example:**
- 5 plants, all different families: family_diversity = 1.0, H/H_max = 1.0 → score = 1.0
- 5 plants, all same family: family_diversity = 0.2, H/H_max = 0.0 → score = 0.12

---

### Positive Factor Aggregation

```python
positive_benefit_score = (
    0.30 * herbivore_control_norm +
    0.30 * pathogen_control_norm +
    0.25 * beneficial_fungi_norm +
    0.15 * diversity_norm
)
# Result: [0, 1] where 0 = no benefits, 1 = maximum beneficial interactions
```

**Rationale for weights:**
- Herbivore control (30%): Critical biological pest control (predators + entomopathogenic fungi)
- Pathogen control (30%): Critical biological disease control (antagonists + mycoparasites)
- Beneficial fungi networks (25%): Strong nutrient sharing and soil health (mycorrhizae + endophytes + saprotrophs)
- Taxonomic diversity (15%): Indirect but important resilience factor

---

## Final Guild Score

### Balanced [-1, +1] Scoring

```python
guild_score = positive_benefit_score - negative_risk_score

# Range: [-1, +1]
# -1.0 = Maximum shared vulnerabilities, no beneficial interactions (catastrophic)
# -0.5 = Significant risks, minimal benefits (poor guild)
#  0.0 = Balanced risks and benefits (neutral)
# +0.5 = Some benefits, manageable risks (good guild)
# +1.0 = Maximum beneficial interactions, minimal shared vulnerabilities (excellent)
```

### Interpretation Thresholds

```python
def get_interpretation(score):
    if score >= 0.7:
        return "Excellent guild - strong beneficial interactions, minimal shared risks"
    elif score >= 0.3:
        return "Good guild - beneficial interactions outweigh risks"
    elif score >= -0.3:
        return "Neutral guild - balanced risks and benefits"
    elif score >= -0.7:
        return "Poor guild - shared vulnerabilities outweigh benefits"
    else:
        return "Bad guild - catastrophic shared vulnerabilities, minimal benefits"
```

### Why This Balancing Works

**Equal reachability of extremes:**
- Worst guild: negative_risk_score = 1.0, positive_benefit_score = 0.0 → **-1.0**
- Best guild: negative_risk_score = 0.0, positive_benefit_score = 1.0 → **+1.0**

**Clear component interpretation:**
- All negative components scored as risks (higher = worse)
- All positive components scored as benefits (higher = better)
- Final subtraction creates intuitive scale

**Balanced weight allocation:**
- Negative factors: 40% + 30% + 30% = 100% (within negative section)
- Positive factors: 30% + 30% + 25% + 15% = 100% (within positive section)
- Each section normalized to [0, 1] before final combination

---

## Implementation Architecture

### Data Flow

```
Input Files:
  - plant_organism_profiles.parquet (11,680 plants)
    → herbivores, pathogens, pollinators, flower_visitors

  - plant_fungal_guilds_hybrid.parquet (11,680 plants)
    → pathogenic_fungi, amf_fungi, emf_fungi, mycoparasite_fungi,
      entomopathogenic_fungi, endophytic_fungi, saprotrophic_fungi

  - herbivore_predators.parquet
    → animal predator-prey relationships (second-order effects)

  - insect_fungal_parasites.parquet **NEW**
    → herbivore→fungal parasite relationships (1,212 insects/mites)

  - pathogen_antagonists.parquet
    → antagonist-pathogen relationships (biocontrol)

        ↓

05_compute_guild_compatibility.py (NEW)
  - Load all plants in guild
  - Count shared organisms (overlap analysis)
  - Identify cross-benefits (predator-prey, antagonist-pathogen)
  - Compute negative_risk_score [0, 1]
  - Compute positive_benefit_score [0, 1]
  - Final: guild_score = positive - negative

        ↓

Output: Guild score [-1, +1] with component breakdown
```

### DuckDB Implementation

**File:** `src/Stage_4/05_compute_guild_compatibility.py`

**Core algorithm:**

```python
import duckdb
import math
from collections import Counter

def compute_guild_score(plant_ids):
    """
    Compute guild-level compatibility score based on overlap analysis.

    Args:
        plant_ids: List of WFO IDs (e.g., ['wfo-001', 'wfo-002', ...])

    Returns:
        dict with score and component breakdown
    """
    con = duckdb.connect()
    n_plants = len(plant_ids)
    max_pairs = n_plants * (n_plants - 1)

    # Load organism profiles
    profiles = con.execute(f"""
        SELECT
            plant_wfo_id,
            herbivores,
            pathogens,
            pollinators,
            flower_visitors
        FROM read_parquet('data/stage4/plant_organism_profiles.parquet')
        WHERE plant_wfo_id IN ({','.join([f"'{x}'" for x in plant_ids])})
    """).fetchdf()

    # Load fungal guilds
    fungal = con.execute(f"""
        SELECT
            plant_wfo_id,
            pathogenic_fungi,
            pathogenic_fungi_host_specific,
            amf_fungi,
            emf_fungi,
            mycoparasite_fungi,
            entomopathogenic_fungi,
            endophytic_fungi,
            saprotrophic_fungi
        FROM read_parquet('data/stage4/plant_fungal_guilds_hybrid.parquet')
        WHERE plant_wfo_id IN ({','.join([f"'{x}'" for x in plant_ids])})
    """).fetchdf()

    # Load predator-prey relationships
    herbivore_predators = con.execute("""
        SELECT herbivore, predators
        FROM read_parquet('data/stage4/herbivore_predators.parquet')
    """).fetchdf()
    herb_pred_map = dict(zip(herbivore_predators['herbivore'],
                             herbivore_predators['predators']))

    # Load insect-fungal parasite relationships **NEW**
    insect_fungal_parasites = con.execute("""
        SELECT herbivore, entomopathogenic_fungi
        FROM read_parquet('data/stage4/insect_fungal_parasites.parquet')
    """).fetchdf()
    insect_fungal_map = dict(zip(insect_fungal_parasites['herbivore'],
                                 insect_fungal_parasites['entomopathogenic_fungi']))

    # Load pathogen-antagonist relationships
    pathogen_antagonists = con.execute("""
        SELECT pathogen, antagonists
        FROM read_parquet('data/stage4/pathogen_antagonists.parquet')
    """).fetchdf()
    path_antag_map = dict(zip(pathogen_antagonists['pathogen'],
                              pathogen_antagonists['antagonists']))

    # ========================================
    # NEGATIVE FACTORS
    # ========================================

    # N1: Pathogenic Fungi Overlap
    shared_path_fungi = count_shared_organisms(fungal, 'pathogenic_fungi')
    host_specific = get_host_specific_set(fungal)

    pathogen_fungi_raw = 0
    for fungus, plant_count in shared_path_fungi.items():
        if plant_count < 2:
            continue

        overlap_ratio = plant_count / n_plants
        overlap_penalty = overlap_ratio ** 2

        severity = 1.0 if fungus in host_specific else 0.6
        pathogen_fungi_raw += overlap_penalty * severity

    pathogen_fungi_norm = math.tanh(pathogen_fungi_raw / 8.0)

    # N2: Herbivore Overlap
    shared_herbivores = count_shared_organisms(profiles, 'herbivores')

    herbivore_raw = 0
    for herbivore, plant_count in shared_herbivores.items():
        if plant_count < 2:
            continue

        overlap_ratio = plant_count / n_plants
        overlap_penalty = overlap_ratio ** 2
        herbivore_raw += overlap_penalty * 0.5

    herbivore_norm = math.tanh(herbivore_raw / 4.0)

    # N3: Non-Fungal Pathogen Overlap
    shared_pathogens = count_shared_organisms(profiles, 'pathogens')

    pathogen_other_raw = 0
    for pathogen, plant_count in shared_pathogens.items():
        if plant_count < 2:
            continue

        overlap_ratio = plant_count / n_plants
        overlap_penalty = overlap_ratio ** 2
        pathogen_other_raw += overlap_penalty * 0.7

    pathogen_other_norm = math.tanh(pathogen_other_raw / 3.0)

    # Aggregate negative factors
    negative_risk_score = (
        0.40 * pathogen_fungi_norm +
        0.30 * herbivore_norm +
        0.30 * pathogen_other_norm
    )

    # ========================================
    # POSITIVE FACTORS
    # ========================================

    # P1: Herbivore Control Benefits (predators + specific fungi + general fungi)
    herbivore_control_raw = 0

    for idx_a, plant_a in profiles.iterrows():
        herbivores_a = set(plant_a['herbivores']) if plant_a['herbivores'] is not None else set()

        for idx_b, plant_b in profiles.iterrows():
            if idx_a == idx_b:
                continue

            # Mechanism 1: Specific animal predators (weight 1.0)
            visitors_b = set(plant_b['flower_visitors']) if plant_b['flower_visitors'] is not None else set()

            for herbivore in herbivores_a:
                if herbivore not in herb_pred_map:
                    continue

                predators = set(herb_pred_map[herbivore])
                beneficial = visitors_b.intersection(predators)
                herbivore_control_raw += len(beneficial) * 1.0  # Specific predator match

            # Mechanism 2: Specific entomopathogenic fungi (weight 1.0) **NEW**
            entomopathogenic_b = set(fungal.iloc[idx_b]['entomopathogenic_fungi']) if fungal.iloc[idx_b]['entomopathogenic_fungi'] is not None else set()

            for herbivore in herbivores_a:
                if herbivore not in insect_fungal_map:
                    continue

                parasites = set(insect_fungal_map[herbivore])
                beneficial_fungi = entomopathogenic_b.intersection(parasites)
                herbivore_control_raw += len(beneficial_fungi) * 1.0  # Specific fungus match

            # Mechanism 3: General entomopathogenic fungi (weight 0.3)
            if len(herbivores_a) > 0 and len(entomopathogenic_b) > 0:
                herbivore_control_raw += len(entomopathogenic_b) * 0.3  # General benefit

    herbivore_control_norm = math.tanh(herbivore_control_raw / max_pairs * 10) if max_pairs > 0 else 0

    # P2: Pathogen Control Benefits (antagonists + mycoparasites)
    pathogen_control_raw = 0

    for idx_a, plant_a in fungal.iterrows():
        pathogens_a = set(plant_a['pathogenic_fungi']) if plant_a['pathogenic_fungi'] is not None else set()

        for idx_b, plant_b in fungal.iterrows():
            if idx_a == idx_b:
                continue

            mycoparasites_b = set(plant_b['mycoparasite_fungi']) if plant_b['mycoparasite_fungi'] is not None else set()

            # Mechanism 1: Specific antagonist matches
            for pathogen in pathogens_a:
                if pathogen not in path_antag_map:
                    continue

                antagonists = set(path_antag_map[pathogen])
                beneficial = mycoparasites_b.intersection(antagonists)
                pathogen_control_raw += len(beneficial) * 1.0  # Specific match

            # Mechanism 2: General mycoparasite benefit
            if len(pathogens_a) > 0 and len(mycoparasites_b) > 0:
                pathogen_control_raw += len(mycoparasites_b) * 0.3  # General benefit

    pathogen_control_norm = math.tanh(pathogen_control_raw / max_pairs * 10) if max_pairs > 0 else 0

    # P3: Shared Beneficial Fungi (mycorrhizae + endophytes + saprotrophs)
    shared_beneficial = count_shared_organisms(
        fungal,
        'amf_fungi',
        'emf_fungi',
        'endophytic_fungi',
        'saprotrophic_fungi'
    )

    network_raw = 0
    for fungus, plant_count in shared_beneficial.items():
        if plant_count >= 2:
            coverage = plant_count / n_plants
            network_raw += coverage

    plants_with_beneficial = sum(1 for _, plant in fungal.iterrows()
        if (plant['amf_fungi'] is not None and len(plant['amf_fungi']) > 0) or
           (plant['emf_fungi'] is not None and len(plant['emf_fungi']) > 0) or
           (plant['endophytic_fungi'] is not None and len(plant['endophytic_fungi']) > 0) or
           (plant['saprotrophic_fungi'] is not None and len(plant['saprotrophic_fungi']) > 0))

    coverage_ratio = plants_with_beneficial / n_plants

    beneficial_fungi_raw = network_raw * 0.6 + coverage_ratio * 0.4
    beneficial_fungi_norm = math.tanh(beneficial_fungi_raw / 3.0)

    # P4: Taxonomic Diversity
    taxonomy = con.execute(f"""
        SELECT wfo_taxon_id, wfo_family
        FROM read_parquet('model_data/outputs/perm2_production/perm2_11680_with_ecoservices_20251030.parquet')
        WHERE wfo_taxon_id IN ({','.join([f"'{x}'" for x in plant_ids])})
    """).fetchdf()

    families = set(taxonomy['wfo_family'].dropna())
    family_diversity = len(families) / n_plants

    family_counts = Counter(taxonomy['wfo_family'].dropna())
    H = 0
    for count in family_counts.values():
        p = count / n_plants
        if p > 0:
            H -= p * math.log(p)

    H_max = math.log(n_plants) if n_plants > 1 else 1
    shannon_norm = H / H_max if H_max > 0 else 0

    diversity_norm = family_diversity * 0.6 + shannon_norm * 0.4

    # Aggregate positive factors
    positive_benefit_score = (
        0.30 * herbivore_control_norm +
        0.30 * pathogen_control_norm +
        0.25 * beneficial_fungi_norm +
        0.15 * diversity_norm
    )

    # ========================================
    # FINAL GUILD SCORE
    # ========================================

    guild_score = positive_benefit_score - negative_risk_score

    return {
        'guild_score': guild_score,
        'negative_risk_score': negative_risk_score,
        'positive_benefit_score': positive_benefit_score,
        'negative_components': {
            'pathogenic_fungi_overlap': pathogen_fungi_norm,
            'herbivore_overlap': herbivore_norm,
            'pathogen_overlap': pathogen_other_norm
        },
        'positive_components': {
            'herbivore_control': herbivore_control_norm,
            'pathogen_control': pathogen_control_norm,
            'beneficial_fungi_networks': beneficial_fungi_norm,
            'taxonomic_diversity': diversity_norm
        },
        'raw_scores': {
            'pathogenic_fungi': pathogen_fungi_raw,
            'herbivores': herbivore_raw,
            'pathogens_other': pathogen_other_raw,
            'herbivore_control': herbivore_control_raw,
            'pathogen_control': pathogen_control_raw,
            'beneficial_fungi': beneficial_fungi_raw
        },
        'overlap_counts': {
            'shared_pathogenic_fungi': len([k for k, v in shared_path_fungi.items() if v >= 2]),
            'shared_herbivores': len([k for k, v in shared_herbivores.items() if v >= 2]),
            'shared_pathogens': len([k for k, v in shared_pathogens.items() if v >= 2]),
            'shared_beneficial_fungi': len([k for k, v in shared_beneficial.items() if v >= 2]),
            'herbivore_control_benefits': int(herbivore_control_raw),
            'pathogen_control_benefits': int(pathogen_control_raw)
        },
        'interpretation': get_interpretation(guild_score)
    }


def count_shared_organisms(data, *columns):
    """
    Count how many plants have each organism across specified columns.

    Args:
        data: DataFrame with plant organism data
        *columns: Column names to aggregate (e.g., 'herbivores', 'amf_fungi')

    Returns:
        Counter mapping organism → count of plants with it
    """
    organism_counts = Counter()

    for _, row in data.iterrows():
        for col in columns:
            organisms = row[col]
            if organisms is not None and len(organisms) > 0:
                for org in organisms:
                    organism_counts[org] += 1

    return organism_counts


def get_host_specific_set(fungal_data):
    """Extract set of host-specific pathogenic fungi."""
    host_specific = set()
    for _, row in fungal_data.iterrows():
        if row['pathogenic_fungi_host_specific'] is not None:
            host_specific.update(row['pathogenic_fungi_host_specific'])
    return host_specific


def get_interpretation(score):
    """Convert score to user-friendly interpretation."""
    if score >= 0.7:
        return "Excellent guild - strong beneficial interactions, minimal shared risks"
    elif score >= 0.3:
        return "Good guild - beneficial interactions outweigh risks"
    elif score >= -0.3:
        return "Neutral guild - balanced risks and benefits"
    elif score >= -0.7:
        return "Poor guild - shared vulnerabilities outweigh benefits"
    else:
        return "Bad guild - catastrophic shared vulnerabilities, minimal benefits"
```

---

## Expected Performance

### Test Cases

**Bad Guild (5 Acacias, 40 shared pathogenic fungi):**

Current pairwise: **0.266**

**Expected guild-level breakdown:**

Negative components:
- Pathogenic fungi overlap: 0.996 (40 fungi, many on 4-5 plants, quadratic penalty)
- Herbivore overlap: 0.40 (6 shared herbivores)
- Pathogen overlap: 0.15 (some shared non-fungal)
- **negative_risk_score = 0.40×0.996 + 0.30×0.40 + 0.30×0.15 = 0.643**

Positive components:
- Predator cross-benefits: 0.02 (minimal)
- Antagonist cross-benefits: 0.01 (minimal)
- Mycorrhizal networks: 0.05 (some shared AMF)
- Taxonomic diversity: 0.12 (all same genus)
- **positive_benefit_score = 0.30×0.02 + 0.30×0.01 + 0.25×0.05 + 0.15×0.12 = 0.040**

**Guild score = 0.040 - 0.643 = -0.60** (poor guild with shared vulnerabilities)

---

**Good Guild (Diverse, minimal overlap):**

Current pairwise: **0.298**

**Expected guild-level breakdown:**

Negative components:
- Pathogenic fungi overlap: 0.060 (only 5 fungi, each on 2/5 plants)
- Herbivore overlap: 0.02 (zero shared)
- Pathogen overlap: 0.01 (minimal)
- **negative_risk_score = 0.40×0.06 + 0.30×0.02 + 0.30×0.01 = 0.033**

Positive components:
- Predator cross-benefits: 0.60 (diverse plants attract beneficial predators)
- Antagonist cross-benefits: 0.45 (biocontrol fungi benefit across plants)
- Mycorrhizal networks: 0.55 (shared saprotrophic and mycorrhizal fungi)
- Taxonomic diversity: 0.88 (5 different families)
- **positive_benefit_score = 0.30×0.60 + 0.30×0.45 + 0.25×0.55 + 0.15×0.88 = 0.585**

**Guild score = 0.585 - 0.033 = +0.55** (good guild with beneficial interactions)

---

**Discrimination improvement: 36× better**
- Current difference: 0.032
- New difference: 1.15 (from -0.60 to +0.55)
- Improvement: 1.15 / 0.032 = 36×

**Score range utilization:**
- Bad guild reaches -0.60 (60% toward worst possible)
- Good guild reaches +0.55 (55% toward best possible)
- Full [-1, +1] range accessible depending on guild composition

---

## Weight Calibration Plan

### Current Status

Weights are **preliminary estimates** based on ecological principles. Not yet empirically validated.

**Negative factor weights (within negative section):**
- Pathogenic fungi overlap: 40% (disease can destroy entire guilds)
- Herbivore overlap: 30% (pests problematic but less lethal than disease)
- Non-fungal pathogen overlap: 30% (important but less data)

**Positive factor weights (within positive section):**
- Predator cross-benefits: 30% (biological pest control critical)
- Antagonist cross-benefits: 30% (biological disease control critical)
- Mycorrhizal networks: 25% (nutrient sharing benefits)
- Taxonomic diversity: 15% (indirect resilience)

### Calibration Approach

**Phase 1: Collect ground truth guilds (N=50-100)**

Known good guilds:
- Three Sisters (corn + beans + squash)
- Forest gardens (canopy + understory + ground + nitrogen fixers)
- Beneficial insectary borders
- Silvopasture systems

Known bad guilds:
- All Solanaceae (shared diseases)
- Monoculture orchards (disease cascades)
- Disease-prone combinations (roses + apples + hawthorn)
- Brassica monocultures

**Phase 2: Optimize weights via regression**

```python
from sklearn.linear_model import Ridge
from sklearn.model_selection import cross_val_score

# Separate negative and positive component matrices
X_neg = negative_component_scores  # (N_guilds, 3)
X_pos = positive_component_scores  # (N_guilds, 4)
y = guild_quality_scores  # Expert ratings: -1 to +1

# Optimize negative weights
model_neg = Ridge(alpha=1.0, positive=True)  # Force non-negative
model_neg.fit(X_neg, -y)  # Negative correlation with quality
w_neg = model_neg.coef_ / model_neg.coef_.sum()

# Optimize positive weights
model_pos = Ridge(alpha=1.0, positive=True)
model_pos.fit(X_pos, y)  # Positive correlation with quality
w_pos = model_pos.coef_ / model_pos.coef_.sum()

print(f"Negative weights: {w_neg}")
print(f"Positive weights: {w_pos}")
```

**Phase 3: Validation on holdout set**

- Hold out 20% of guilds
- Validate predictions
- Compute correlation, classification accuracy, rank preservation

---

## Migration Path

### Phase 1: Implement Guild Scorer

- [ ] Create `src/Stage_4/05_compute_guild_compatibility.py` with DuckDB
- [ ] Implement 3 negative + 4 positive components with overlap counting
- [ ] Add second-order effects (predator-prey, antagonist-pathogen)
- [ ] Test on 2 guilds (bad Acacia, good diverse)
- [ ] Validate discrimination improvement (target: 35-40× better)

### Phase 2: Production Integration

- [ ] Replace `guild_builder_prototype.py` pairwise averaging with new scorer
- [ ] Add guild score to frontend with component breakdown
- [ ] Display negative_risk_score and positive_benefit_score separately
- [ ] Performance optimization (cache lookup tables, vectorize)

### Phase 3: Calibration & Validation

- [ ] Collect 50-100 ground truth guilds
- [ ] Optimize negative and positive weights separately
- [ ] Cross-validate on holdout set
- [ ] Document final weights with ecological rationale

---

## Documentation Status

**Supersedes:**
- Previous 4.2 Implementation Plan (pairwise matrix approach)
- Previous 4.3 Guild Builder Design (pairwise compatibility)

**Integrates with:**
- 4.1 GloBI Data Structure Analysis (data sources)
- 4.5 Fungal Guild Classification (FungalTraits hybrid approach)
- Guild Builder Network Effects Framework (second-order trophic effects)

**Status**: Framework design complete, implementation pending

**Last Updated**: 2025-11-02
