# Stage 4.2c: 7-Metric Framework with Faith's Phylogenetic Diversity

**Document:** 4.2c - Faith's PD Implementation for Pest/Pathogen Independence
**Date:** 2025-11-05
**Purpose:** Implementation plan for M1 metric using Faith's Phylogenetic Diversity with CompactTree C++
**Status:** Implementation Ready

---

## Executive Summary

**Key Change:** Use **Faith's Phylogenetic Diversity** calculated directly from phylogenetic tree as M1 (Pathogen & Pest Independence), replacing:
- N1 (Pathogen Independence) - sparse data
- N2 (Pest Independence) - sparse data
- Old P4 (phylogenetic eigenvector distances) - abandoned approach

**Method:** CompactTree C++ library for ultra-fast Faith's PD calculation (2.5 microseconds per guild).

**Result:** Framework uses 7 calibrated metrics with M1 providing 100% plant coverage and literature-validated pest risk prediction.

---

## Literature Justification

### Faith's Phylogenetic Diversity for Pest/Pathogen Risk

**Faith's PD Definition:**
```
PD = Σ (unique branch lengths from species to their MRCA)
```

Where MRCA = Most Recent Common Ancestor

**Why Faith's PD predicts pest sharing:**

**1. Silva-Valderrama et al. 2025 - Ecological Monographs**
- "Host phylogeny has greater influence in determining [pathogen] interaction"
- Strong phylogenetic signal in pest-host associations (ParaFitGlobal test: p<0.001)
- Closely related plants share similar pathogens and herbivores

**2. Gilbert & Webb 2007 (Phylopathogen Study)**
- Empirical pest sharing decay with phylogenetic distance:
  - **Congeneric (54 My)**: 66.7% pest sharing
  - **Confamilial (85 My)**: 43.6% pest sharing
  - **Distant (233 My)**: 29.9% pest sharing
- Exponential decay pattern: `pest_sharing ∝ exp(-k × PD)`

**3. Gougherty-Davies 2021**
- "Phylogenetic constraints operate across pest types"
- Unified phylogenetic signal for pathogens AND herbivores
- Regression: `logit(S) = β₀ - β₁ × log₁₀(PD + 1)`

**4. Dilution Effect (Keesing et al. 2006)**
- Diverse communities dilute pathogen transmission
- Higher diversity → lower disease prevalence
- Mechanism: non-competent hosts "dilute" pathogen pool

### Conclusion

**Faith's PD serves dual purpose:**
1. **Ecosystem function** (resilience, resource complementarity)
2. **Pest/pathogen barrier** (reduced transmission, host-specificity barriers)

**A single metric captures both benefits.**

---

## Faith's PD vs Previous Approaches

### Comparison

| Approach | Coverage | Speed | Accuracy | Issues |
|----------|----------|-------|----------|--------|
| **Faith's PD (NEW)** | **100%** | **0.0025 ms** | **Literature-validated** | **None** |
| Phylogenetic eigenvectors | 100% | 8.6 ms | Approximation | Failed for recommendations |
| N1/N2 overlap counts | 28.3% | N/A | False precision | Sparse data, biogeographic mismatch |

### Why Eigenvector Approach Failed

**Problem:** Attempted to use phylogenetic embeddings for fast recommendations in Stage 4.6.

**Method:**
1. Eigendecomposition of phylogenetic VCV matrix → 92 eigenvectors
2. Embed species in 92-D space
3. Use vector algebra to predict PD increments

**Result:** **8% recommendation accuracy** (failed)

**Root cause:** Faith's PD is set-based metric depending on tree topology, not reducible to vector algebra. Adding species C to guild [A, B] depends on where C attaches to existing MRCA, which can't be inferred from Euclidean distance in embedding space.

**Solution:** Calculate Faith's PD directly from tree using CompactTree C++ (1,375× faster than Python).

---

## Benchmarking Results

### Performance Comparison

We benchmarked 4 implementations on an 11,676-species phylogenetic tree with a 3-species test guild:

| Implementation | Median Latency | Throughput | Speedup | Deployment |
|---|---|---|---|---|
| **CompactTree (C++)** | **0.0025 ms** | **399,361 guilds/sec** | **1×** | **Compile binary** |
| TreeSwift (C++ backend) | 8.56 ms | 117 guilds/sec | 3,426× slower | `pip install` |
| ete3 (Python) | 8.64 ms | 116 guilds/sec | 3,456× slower | `pip install` |
| R picante (C) | 13.00 ms | 77 guilds/sec | 5,200× slower | R package |

**All implementations produce identical Faith's PD: 654.65 ✓**

### Cost Analysis (10,000 concurrent users)

**TreeSwift (8.6ms):**
- Throughput: 116 guilds/second/core
- Required: 86 CPU cores
- AWS c7g.2xlarge (8 vCPU): 11 instances × $0.29/hr = **$2,537/month**

**CompactTree C++ (0.0025ms):**
- Throughput: 399,000 guilds/second/core
- Required: 0.025 cores (fraction of one core!)
- AWS c7g.large (2 vCPU): 1 instance × $0.07/hr = **$58/month**

**Savings: $2,479/month = $29,748/year**

### Recommendation

**Use CompactTree C++ for production** due to:
1. **1,375× faster than Python** - enables real-time recommendations
2. **Minimal cloud costs** - single small instance handles 10K users
3. **No dependency issues** - single compiled binary
4. **Deployment simplicity** - statically linked, no Python environment needed

---

## Implementation Architecture

### M1 Metric Calculation Flow

```
User requests guild score
    ↓
Extract WFO IDs for plants
    ↓
Map WFO IDs → tree tip labels (CSV lookup)
    ↓
Call C++ binary: calculate_faiths_pd <tree.nwk> <species1> <species2> ...
    ↓
Parse stdout: Faith's PD value
    ↓
Apply exponential transformation: pest_risk = exp(-k × PD)
    ↓
Normalize to percentile using tier-stratified calibration
    ↓
Invert: M1 = 100 - percentile(pest_risk)
    ↓
Return M1 score (high = good)
```

### File Structure

```
/home/olier/ellenberg/
├── CompactTree/                          # C++ library
│   └── CompactTree/
│       └── compact_tree.h                # Header-only library
├── src/Stage_4/
│   ├── calculate_faiths_pd.cpp           # Standalone C++ binary
│   ├── guild_scorer_v3.py                # Python scorer (calls C++ binary)
│   └── calibrate_tier_stratified_7metrics.py  # Calibration script
├── data/stage1/phlogeny/
│   ├── mixgb_tree_11676_species_20251027.nwk         # Phylogenetic tree
│   └── mixgb_wfo_to_tree_mapping_11676.csv           # WFO → tree tip mapping
└── data/stage4/
    └── normalization_params_7metrics_tier_stratified.json  # Calibration
```

---

## CompactTree C++ Implementation

### Step 1: Standalone Faith's PD Binary

**File:** `src/Stage_4/calculate_faiths_pd.cpp`

```cpp
/**
 * Calculate Faith's Phylogenetic Diversity for a guild
 *
 * Usage:
 *   ./calculate_faiths_pd <tree.nwk> <species1> <species2> ...
 *
 * Output:
 *   <Faith's PD value>
 */

#include <iostream>
#include <vector>
#include <unordered_set>
#include "compact_tree.h"

// Calculate Faith's PD
double calculate_faiths_pd(const compact_tree& tree,
                          const std::vector<std::string>& species_labels) {
    if (species_labels.size() == 0) return 0.0;
    if (species_labels.size() == 1) return 0.0;  // No diversity

    // Find leaf nodes
    std::vector<CT_NODE_T> leaf_nodes;
    for (CT_NODE_T i = 0; i < tree.get_num_nodes(); i++) {
        if (tree.is_leaf(i)) {
            std::string label = tree.get_label(i);
            for (const auto& sp : species_labels) {
                if (label == sp) {
                    leaf_nodes.push_back(i);
                    break;
                }
            }
        }
    }

    if (leaf_nodes.size() < 2) return 0.0;

    // Find MRCA
    std::unordered_set<CT_NODE_T> leaf_set(leaf_nodes.begin(), leaf_nodes.end());
    CT_NODE_T mrca = tree.find_mrca(leaf_set);

    // Sum unique branch lengths from each leaf to MRCA
    std::unordered_set<CT_NODE_T> visited_nodes;
    double total_pd = 0.0;

    for (CT_NODE_T leaf : leaf_nodes) {
        CT_NODE_T current = leaf;
        while (current != mrca) {
            if (visited_nodes.find(current) == visited_nodes.end()) {
                total_pd += tree.get_edge_length(current);
                visited_nodes.insert(current);
            }
            current = tree.get_parent(current);
        }
    }

    return total_pd;
}

int main(int argc, char** argv) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <tree.nwk> <species1> <species2> ..." << std::endl;
        return 1;
    }

    // Load tree
    compact_tree tree(argv[1]);

    // Extract species labels
    std::vector<std::string> species_labels;
    for (int i = 2; i < argc; i++) {
        species_labels.push_back(argv[i]);
    }

    // Calculate and output Faith's PD
    double faiths_pd = calculate_faiths_pd(tree, species_labels);
    std::cout << faiths_pd << std::endl;

    return 0;
}
```

**Compile:**
```bash
g++ -O3 -std=c++11 -o calculate_faiths_pd calculate_faiths_pd.cpp \
    -I CompactTree/CompactTree
```

**Test:**
```bash
./calculate_faiths_pd data/stage1/phlogeny/mixgb_tree_11676_species_20251027.nwk \
    "wfo-0000510888|Abelmoschus_moschatus" \
    "wfo-0000510976|Abies_alba" \
    "wfo-0000511376|Abies_religiosa"

# Output: 654.649
```

### Step 2: Python Wrapper

**File:** `src/Stage_4/guild_scorer_v3.py`

```python
def _compute_metric1_pest_pathogen_independence(self, plants_data, n_plants):
    """
    Metric 1: Pathogen & Pest Independence via Faith's Phylogenetic Diversity.

    HIGH diversity → LOW shared pests/pathogens (exponential decay)

    Literature basis:
    - Silva-Valderrama 2025: Host phylogeny determines pest associations
    - Phylopathogen 2013: 66.7% congeneric → 29.9% distant pest sharing
    - Dilution effect: Diverse communities reduce disease transmission

    Implementation:
    - Calls C++ binary for Faith's PD calculation (0.0025 ms)
    - Applies exponential transformation: pest_risk = exp(-k × PD)
    - Normalizes using tier-stratified calibration

    Args:
        plants_data: DataFrame with plant WFO IDs
        n_plants: Number of plants in guild

    Returns:
        dict with 'raw' (pest_risk after exponential transform) and 'norm' (percentile 0-100)
    """
    if n_plants < 2:
        # Single plant: no diversity, maximum pest risk
        return {'raw': 1.0, 'norm': 0.0, 'faiths_pd': 0.0}

    # Load WFO → tree tip mapping
    mapping_df = pd.read_csv('data/stage1/phlogeny/mixgb_wfo_to_tree_mapping_11676.csv')
    wfo_to_tip = dict(zip(mapping_df['wfo_taxon_id'], mapping_df['tree_tip']))

    # Convert WFO IDs to tree tips
    tree_tips = []
    for wfo_id in plants_data['wfo_taxon_id']:
        if wfo_id in wfo_to_tip:
            tree_tips.append(wfo_to_tip[wfo_id])

    if len(tree_tips) < 2:
        return {'raw': 1.0, 'norm': 0.0, 'faiths_pd': 0.0}

    # Call C++ binary to calculate Faith's PD
    tree_path = 'data/stage1/phlogeny/mixgb_tree_11676_species_20251027.nwk'
    binary_path = './src/Stage_4/calculate_faiths_pd'

    cmd = [binary_path, tree_path] + tree_tips
    result = subprocess.run(cmd, capture_output=True, text=True, timeout=1.0)

    if result.returncode != 0:
        print(f"Error calculating Faith's PD: {result.stderr}")
        return {'raw': 1.0, 'norm': 0.0, 'faiths_pd': 0.0}

    faiths_pd = float(result.stdout.strip())

    # Apply exponential transformation (literature-based)
    # Pest sharing decays exponentially with phylogenetic distance:
    #   logit(S) = β₀ - β₁ × log(distance)
    #   → S ∝ exp(-k × distance) in real space
    #
    # Decay constant k calibrated to literature:
    # - Phylopathogen: β₁ = 1.5944 suggests k ≈ 2.5-3.5
    # - Gougherty-Davies: β₁ = 0.748-0.998 suggests k ≈ 2.0-3.0
    # - Use k = 3.0 (middle of range)
    k = 3.0  # Exponential decay constant

    # Transform to PEST RISK (high = bad, low = good)
    # Low Faith's PD (close relatives) → high pest_risk
    # High Faith's PD (distant relatives) → low pest_risk
    pest_risk_raw = np.exp(-k * faiths_pd)

    # Normalize using tier-stratified calibration
    # HIGH pest_risk_raw = HIGH clustering = BAD (low percentile)
    # LOW pest_risk_raw = HIGH diversity = GOOD (high percentile)
    m1_norm = self._normalize_percentile(pest_risk_raw, 'm1')

    return {
        'raw': pest_risk_raw,           # Exponentially transformed (0-1 scale)
        'norm': m1_norm,                # Percentile rank (0-100)
        'faiths_pd': faiths_pd          # Raw Faith's PD (for diagnostics)
    }
```

### Step 3: Calibration

**File:** `src/Stage_4/calibrate_tier_stratified_7metrics.py`

```python
#!/usr/bin/env python3
"""
Calibrate 7-metric framework using Faith's PD for M1.

For each Köppen climate tier:
1. Sample 20,000 random guilds (sizes 2-7)
2. Calculate M1 using Faith's PD (C++ binary)
3. Calculate percentiles for tier-specific normalization

Output: normalization_params_7metrics_tier_stratified.json
"""

import subprocess
import json
import numpy as np
import pandas as pd
from tqdm import tqdm

def calculate_faiths_pd_calibration(tree_path, tree_tips):
    """Call C++ binary for Faith's PD."""
    binary_path = './src/Stage_4/calculate_faiths_pd'
    cmd = [binary_path, tree_path] + tree_tips

    result = subprocess.run(cmd, capture_output=True, text=True, timeout=1.0)
    if result.returncode != 0:
        return 0.0

    return float(result.stdout.strip())

def calibrate_m1(tier_plants, tree_path, n_guilds=20000):
    """
    Calibrate M1 metric for a climate tier.

    Returns percentiles of pest_risk (exp(-k × PD)) distribution.
    """
    print(f"Calibrating M1 for {len(tier_plants)} plants...")

    raw_scores = []

    for i in tqdm(range(n_guilds)):
        # Sample random guild (size 2-7)
        guild_size = np.random.choice([2, 3, 4, 5, 6, 7])
        guild_plants = np.random.choice(tier_plants, guild_size, replace=False)

        # Calculate Faith's PD
        faiths_pd = calculate_faiths_pd_calibration(tree_path, guild_plants.tolist())

        # Apply exponential transformation
        k = 3.0
        pest_risk = np.exp(-k * faiths_pd)

        raw_scores.append(pest_risk)

    # Calculate percentiles
    percentiles = {
        'p1': np.percentile(raw_scores, 1),
        'p5': np.percentile(raw_scores, 5),
        'p10': np.percentile(raw_scores, 10),
        'p20': np.percentile(raw_scores, 20),
        'p30': np.percentile(raw_scores, 30),
        'p40': np.percentile(raw_scores, 40),
        'p50': np.percentile(raw_scores, 50),
        'p60': np.percentile(raw_scores, 60),
        'p70': np.percentile(raw_scores, 70),
        'p80': np.percentile(raw_scores, 80),
        'p90': np.percentile(raw_scores, 90),
        'p95': np.percentile(raw_scores, 95),
        'p99': np.percentile(raw_scores, 99),
        'n_samples': n_guilds
    }

    return percentiles

def main():
    # Load plants and mapping
    mapping_df = pd.read_csv('data/stage1/phlogeny/mixgb_wfo_to_tree_mapping_11676.csv')
    wfo_to_tip = dict(zip(mapping_df['wfo_taxon_id'], mapping_df['tree_tip']))

    tree_path = 'data/stage1/phlogeny/mixgb_tree_11676_species_20251027.nwk'

    # Define Köppen tiers (simplified)
    tiers = {
        'tier_1_tropical': [...],      # List of tree tips for tropical plants
        'tier_2_mediterranean': [...],
        'tier_3_humid_temperate': [...],
        'tier_4_continental': [...],
        'tier_5_boreal': [...],
        'tier_6_arid': [...]
    }

    calibration = {}

    for tier_name, tier_tree_tips in tiers.items():
        print(f"\n{'='*70}")
        print(f"Calibrating {tier_name}")
        print(f"{'='*70}")

        # Calibrate M1
        m1_params = calibrate_m1(tier_tree_tips, tree_path, n_guilds=20000)

        calibration[tier_name] = {
            'm1': m1_params
            # ... M2-M7 calibration (unchanged)
        }

    # Save
    with open('data/stage4/normalization_params_7metrics_tier_stratified.json', 'w') as f:
        json.dump(calibration, f, indent=2)

    print("\n✓ Calibration complete!")
    print("  Output: data/stage4/normalization_params_7metrics_tier_stratified.json")

if __name__ == '__main__':
    main()
```

**Run calibration:**
```bash
# Compile C++ binary first
g++ -O3 -std=c++11 -o src/Stage_4/calculate_faiths_pd \
    src/Stage_4/calculate_faiths_pd.cpp \
    -I CompactTree/CompactTree

# Run calibration (6 tiers × 20K guilds = 120K calculations)
conda run -n AI python src/Stage_4/calibrate_tier_stratified_7metrics.py

# Expected runtime: ~5 minutes (0.0025ms × 120K = 300ms + overhead)
# Expected output: ~50 KB JSON file
```

---

## Deployment Strategy

### Option 1: API Server with C++ Binary

**Architecture:**
```
User Browser
    ↓ HTTPS
FastAPI Python Server
    ↓ subprocess call
C++ calculate_faiths_pd binary (statically linked)
    ↓ reads
Phylogenetic tree (11,676 species, 5MB .nwk file)
```

**Pros:**
- Simple deployment (single binary)
- Minimal cloud cost ($58/month for 10K users)
- No Python environment issues

**Cons:**
- Subprocess overhead (~0.5ms)
- File I/O per request (tree loading)

**Optimization:** Load tree once at server startup, use shared memory or keep-alive process.

### Option 2: C++ Microservice

**Architecture:**
```
User Browser
    ↓ HTTPS
FastAPI Python Server (metric assembly)
    ↓ HTTP REST call
C++ Microservice (loads tree once, holds in memory)
    ↓
Return Faith's PD (0.0025 ms calculation)
```

**Pros:**
- Tree loaded once (startup)
- No subprocess overhead
- Ultra-fast (<1ms total)

**Cons:**
- More complex deployment (2 services)
- Need IPC mechanism

**Recommended for production at scale.**

### Option 3: Python with Optimized Library (Fallback)

If C++ deployment becomes problematic, use TreeSwift (8.6ms):
```bash
pip install treeswift
```

**Trade-off:**
- 3,426× slower than C++
- But still <10ms (acceptable for UI)
- Simpler deployment
- Higher cloud costs ($2,537/month vs $58/month)

---

## Testing & Validation

### Unit Tests

**Test 1: Monoculture (Low Diversity = High Pest Risk)**
```python
def test_monoculture_low_m1():
    """Three closely related plants (same genus) should have low M1."""
    guild = [
        'wfo-0000628652',  # Malus domestica
        'wfo-0000628912',  # Malus sylvestris
        'wfo-0000628234'   # Malus baccata
    ]

    scorer = GuildScorer()
    result = scorer.score_guild(guild)

    # Expect LOW percentile (10-30th) for M1
    m1_score = result['metrics']['pest_pathogen_independence']
    assert m1_score < 40, f"Expected low M1 for monoculture, got {m1_score}"

    # Expect low Faith's PD (<100 branch length units)
    faiths_pd = result['components']['m1_pest_pathogen_independence']['faiths_pd']
    assert faiths_pd < 100, f"Expected low PD for congeneric guild, got {faiths_pd}"
```

**Test 2: Polyculture (High Diversity = Low Pest Risk)**
```python
def test_polyculture_high_m1():
    """Three distantly related plants should have high M1."""
    guild = [
        'wfo-0001147018',  # Quercus robur (Fagaceae)
        'wfo-0000601905',  # Rosa canina (Rosaceae)
        'wfo-0000873619'   # Festuca rubra (Poaceae)
    ]

    scorer = GuildScorer()
    result = scorer.score_guild(guild)

    # Expect HIGH percentile (70-95th) for M1
    m1_score = result['metrics']['pest_pathogen_independence']
    assert m1_score > 60, f"Expected high M1 for polyculture, got {m1_score}"

    # Expect high Faith's PD (>500 branch length units)
    faiths_pd = result['components']['m1_pest_pathogen_independence']['faiths_pd']
    assert faiths_pd > 500, f"Expected high PD for diverse guild, got {faiths_pd}"
```

**Test 3: Literature Calibration**
```python
def test_literature_calibration():
    """
    Validate M1 aligns with literature:
    - Congeneric: ~30th percentile (66.7% pest sharing)
    - Confamilial: ~50th percentile (43.6% pest sharing)
    - Distant: ~70th percentile (29.9% pest sharing)
    """
    scorer = GuildScorer()

    # Test pairs from literature
    guild_congeneric = ['wfo-Malus-A', 'wfo-Malus-B']  # Same genus
    guild_confam = ['wfo-Malus-A', 'wfo-Pyrus-B']      # Same family
    guild_distant = ['wfo-Malus-A', 'wfo-Quercus-B']   # Different families

    result_cong = scorer.score_guild(guild_congeneric)
    result_confam = scorer.score_guild(guild_confam)
    result_dist = scorer.score_guild(guild_distant)

    m1_cong = result_cong['metrics']['pest_pathogen_independence']
    m1_confam = result_confam['metrics']['pest_pathogen_independence']
    m1_dist = result_dist['metrics']['pest_pathogen_independence']

    # Literature expectations
    assert 20 < m1_cong < 40, f"Congeneric: expected ~30th, got {m1_cong}"
    assert 40 < m1_confam < 60, f"Confamilial: expected ~50th, got {m1_confam}"
    assert 60 < m1_dist < 80, f"Distant: expected ~70th, got {m1_dist}"
```

### Performance Benchmark

**Verify C++ binary performance:**
```bash
# Benchmark script
time for i in {1..1000}; do
    ./calculate_faiths_pd \
        data/stage1/phlogeny/mixgb_tree_11676_species_20251027.nwk \
        "wfo-0000510888|Abelmoschus_moschatus" \
        "wfo-0000510976|Abies_alba" \
        "wfo-0000511376|Abies_religiosa" \
        > /dev/null
done

# Expected: ~2.5 seconds for 1000 calculations = 2.5ms per calculation
# (includes subprocess overhead + tree loading)
```

**With tree preloading (production):**
```
Expected: <0.01 ms per calculation (0.0025 ms pure calculation + minimal overhead)
```

---

## Scripts Reference

### Benchmarking Scripts (Completed)

**1. Python Implementation Benchmark**
```bash
conda run -n AI python src/Stage_4/benchmark_faiths_pd_implementations.py
```

**Output:**
```
CompactTree (Python wrapper):  3.44 ms
TreeSwift (C++):              8.56 ms
ete3 (Python):                8.64 ms
R picante (C):               13.00 ms
```

**2. Pure C++ Benchmark**
```bash
g++ -O3 -std=c++11 -o src/Stage_4/benchmark_faiths_pd_compacttree \
    src/Stage_4/benchmark_faiths_pd_compacttree.cpp \
    -I CompactTree/CompactTree

./src/Stage_4/benchmark_faiths_pd_compacttree
```

**Output:**
```
Median latency: 0.0025 ms (2.5 microseconds)
Throughput: 399,361 guilds/second/core
Faith's PD: 654.649 ✓
```

**Files:**
- `src/Stage_4/benchmark_faiths_pd_implementations.py` - Python wrapper comparison
- `src/Stage_4/benchmark_faiths_pd_compacttree.cpp` - Pure C++ benchmark
- `results/summaries/phylotraits/Stage_4/faiths_pd_benchmark_results.json` - Results

### Production Scripts (To Implement)

**3. Standalone Faith's PD Calculator**
```bash
# Compile
g++ -O3 -std=c++11 -o calculate_faiths_pd \
    src/Stage_4/calculate_faiths_pd.cpp \
    -I CompactTree/CompactTree

# Test
./calculate_faiths_pd \
    data/stage1/phlogeny/mixgb_tree_11676_species_20251027.nwk \
    "wfo-0000510888|Abelmoschus_moschatus" \
    "wfo-0000510976|Abies_alba" \
    "wfo-0000511376|Abies_religiosa"

# Output: 654.649
```

**4. Calibration Script**
```bash
# Compile binary first
g++ -O3 -std=c++11 -o src/Stage_4/calculate_faiths_pd \
    src/Stage_4/calculate_faiths_pd.cpp \
    -I CompactTree/CompactTree

# Run calibration
conda run -n AI python src/Stage_4/calibrate_tier_stratified_7metrics.py \
    --tiers=1,2,3,4,5,6 \
    --guilds_per_tier=20000 \
    --output=data/stage4/normalization_params_7metrics_tier_stratified.json

# Expected: ~5 minutes (0.0025ms × 120K = fast!)
```

---

## Implementation Checklist

### Phase 1: C++ Binary (1 day)

- [ ] Create `src/Stage_4/calculate_faiths_pd.cpp` (standalone binary)
- [ ] Implement Faith's PD calculation using CompactTree
- [ ] Compile and test with sample guilds
- [ ] Verify output matches benchmark (654.649 for 3-species test)
- [ ] Add error handling (missing species, invalid tree path)
- [ ] Document compilation instructions

### Phase 2: Python Integration (1 day)

- [ ] Update `guild_scorer_v3.py`:
  - [ ] Remove phylogenetic eigenvector loading
  - [ ] Implement `_compute_metric1_pest_pathogen_independence()` with subprocess call
  - [ ] Add exponential transformation (k=3.0)
  - [ ] Add tier-stratified normalization
- [ ] Add WFO → tree tip mapping lookup
- [ ] Handle subprocess errors gracefully
- [ ] Test with 2-plant and 7-plant guilds

### Phase 3: Calibration (1 day)

- [ ] Create `calibrate_tier_stratified_7metrics.py`
- [ ] Implement M1 calibration using C++ binary
- [ ] Run 120K guild calibration (6 tiers × 20K)
- [ ] Validate percentile monotonicity
- [ ] Validate M1 expected range (pest_risk: 0.4-0.9 after exp transform)
- [ ] Save JSON calibration file

### Phase 4: Testing (1 day)

- [ ] Unit test: monoculture (expect low M1)
- [ ] Unit test: polyculture (expect high M1)
- [ ] Unit test: literature calibration (congeneric ~30th, distant ~70th)
- [ ] Integration test: 2-plant comprehensive
- [ ] Integration test: 7-plant comprehensive
- [ ] Performance test: verify <1ms total latency with subprocess

### Phase 5: Deployment (1 day)

- [ ] Create deployment documentation
- [ ] Add systemd service file (if using microservice)
- [ ] Add Docker container (if containerizing)
- [ ] Document AWS deployment (c7g.large instance)
- [ ] Add monitoring/logging
- [ ] Load testing (verify 10K concurrent users)

---

## Success Criteria

**Technical:**
- [ ] C++ binary produces identical results to benchmark (654.649 for test guild)
- [ ] Python subprocess call completes in <1ms
- [ ] Calibration completes in <10 minutes
- [ ] M1 scores align with literature (congeneric ~30th, distant ~70th)
- [ ] All unit tests pass
- [ ] Performance: <5ms total latency for guild scoring

**Production:**
- [ ] Single AWS c7g.large handles 10,000 concurrent users
- [ ] Cloud cost <$100/month
- [ ] Zero downtime deployments
- [ ] Monitoring dashboard shows <1% error rate

**Documentation:**
- [ ] C++ compilation instructions clear
- [ ] Python integration documented
- [ ] Deployment guide complete
- [ ] Benchmarking results documented

---

## Expected Timeline

| Phase | Duration | Dependencies |
|-------|----------|--------------|
| **Phase 1: C++ Binary** | 1 day | None |
| **Phase 2: Python Integration** | 1 day | Phase 1 complete |
| **Phase 3: Calibration** | 1 day | Phases 1-2 complete |
| **Phase 4: Testing** | 1 day | Phases 1-3 complete |
| **Phase 5: Deployment** | 1 day | All phases complete |

**Total: 5 working days**

---

## Key Benefits

1. ✓ **1,375× faster than Python** - Real-time recommendations at massive scale
2. ✓ **$29,748/year cloud savings** - Single small instance vs 11 large instances
3. ✓ **100% plant coverage** - Works for all 11,676 species
4. ✓ **Literature-validated** - Faith's PD directly predicts pest sharing
5. ✓ **No embedding approximations** - Exact tree topology calculation
6. ✓ **Simple deployment** - Single compiled binary, no dependencies
7. ✓ **Scientifically rigorous** - Gold standard phylogenetic diversity metric
8. ✓ **Ultra-low latency** - 2.5 microseconds enables real-time UI

---

**Document Status:** Implementation Ready
**Next Steps:** Begin Phase 1 (C++ Binary)
**Estimated Completion:** 5 working days from start
