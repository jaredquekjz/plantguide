//! Encyclopedia Generator
//!
//! Orchestrates generation of complete encyclopedia pages by combining
//! multiple section modules.

use crate::encyclopedia::sections::{
    s1_identity_card::{PlantIdentity, generate_identity_card},
    s2_growing_requirements::{GrowingRequirementsData, generate_growing_requirements},
    s3_maintenance_profile::{MaintenanceData, generate_maintenance_profile},
    s4_ecosystem_services::{EcosystemServicesData, generate_ecosystem_services},
    s5_biological_interactions::{BiologicalInteractionsData, OrganismCounts, FungalCounts, generate_biological_interactions},
    s6_companion_planting::{CompanionPlantingData, generate_companion_planting},
    s7_biodiversity_value::{BiodiversityValueData, generate_biodiversity_value},
};

use chrono::Utc;
use std::collections::HashMap;

/// Encyclopedia page generator
pub struct EncyclopediaGenerator;

impl EncyclopediaGenerator {
    pub fn new() -> Self {
        Self
    }

    /// Generate complete encyclopedia page from plant data
    ///
    /// # Arguments
    /// * `plant_data` - HashMap of plant column values (from DataFusion query)
    /// * `organism_counts` - Optional organism interaction counts
    /// * `fungal_counts` - Optional fungal association counts
    pub fn generate(
        &self,
        wfo_id: &str,
        plant_data: &HashMap<String, serde_json::Value>,
        organism_counts: Option<OrganismCounts>,
        fungal_counts: Option<FungalCounts>,
    ) -> Result<String, String> {
        // Extract plant identity
        let plant_identity = PlantIdentity::from_row(plant_data)
            .ok_or_else(|| "Failed to extract plant identity data".to_string())?;

        let scientific_name = &plant_identity.scientific_name;

        // Generate sections
        let mut sections = Vec::new();

        // YAML frontmatter
        let timestamp = Utc::now().format("%Y-%m-%d").to_string();
        sections.push(format!(
            "---\nwfo_id: {}\nscientific_name: {}\ngenerated: {}\ngenerator: Rust Encyclopedia v1.0\n---",
            wfo_id, scientific_name, timestamp
        ));

        // Section 1: Identity Card
        sections.push(generate_identity_card(&plant_identity));
        sections.push("---".to_string());

        // Section 2: Growing Requirements
        let growing_data = GrowingRequirementsData::from_row(plant_data);
        sections.push(generate_growing_requirements(&growing_data));
        sections.push("---".to_string());

        // Section 3: Maintenance Profile
        let maintenance_data = extract_maintenance_data(plant_data);
        sections.push(generate_maintenance_profile(&maintenance_data));
        sections.push("---".to_string());

        // Section 4: Ecosystem Services
        let ecosystem_data = extract_ecosystem_data(plant_data);
        sections.push(generate_ecosystem_services(&ecosystem_data));
        sections.push("---".to_string());

        // Section 5: Biological Interactions
        let bio_data = BiologicalInteractionsData {
            organisms: organism_counts.clone(),
            fungi: fungal_counts.clone(),
            mycorrhiza_type: plant_data.get("try_mycorrhiza_type")
                .and_then(|v| v.as_str())
                .map(|s| s.to_string()),
        };
        sections.push(generate_biological_interactions(&bio_data));
        sections.push("---".to_string());

        // Section 6: Companion Planting (placeholder - requires pre-computed data)
        let companion_data = CompanionPlantingData {
            top_companions: vec![],
            plants_to_avoid: vec![],
        };
        sections.push(generate_companion_planting(&companion_data));
        sections.push("---".to_string());

        // Section 7: Biodiversity Value
        let biodiversity_data = BiodiversityValueData {
            organisms: organism_counts,
            fungi: fungal_counts,
            ecosystem_services_avg: calculate_ecosystem_avg(plant_data),
        };
        sections.push(generate_biodiversity_value(&biodiversity_data));

        // Footer
        sections.push("---".to_string());
        sections.push("*Generated by Rust encyclopedia generator*".to_string());
        sections.push("*Data sources: EIVE (Dengler et al. 2023), CSR (Pierce et al. 2017), TRY database*".to_string());

        Ok(sections.join("\n\n"))
    }
}

impl Default for EncyclopediaGenerator {
    fn default() -> Self {
        Self::new()
    }
}

fn extract_maintenance_data(row: &HashMap<String, serde_json::Value>) -> MaintenanceData {
    MaintenanceData {
        csr_c: row.get("C").and_then(|v| v.as_f64())
            .or_else(|| row.get("C_norm").and_then(|v| v.as_f64())),
        csr_s: row.get("S").and_then(|v| v.as_f64())
            .or_else(|| row.get("S_norm").and_then(|v| v.as_f64())),
        csr_r: row.get("R").and_then(|v| v.as_f64())
            .or_else(|| row.get("R_norm").and_then(|v| v.as_f64())),
        growth_form: row.get("try_growth_form").and_then(|v| v.as_str()).map(|s| s.to_string()),
        height_m: row.get("height_m").and_then(|v| v.as_f64()),
        leaf_phenology: row.get("try_leaf_phenology").and_then(|v| v.as_str()).map(|s| s.to_string()),
        decomposition_rating: row.get("decomposition_rating").and_then(|v| v.as_f64()),
        decomposition_confidence: row.get("decomposition_confidence").and_then(|v| v.as_f64()),
    }
}

fn extract_ecosystem_data(row: &HashMap<String, serde_json::Value>) -> EcosystemServicesData {
    EcosystemServicesData {
        carbon_rating: row.get("carbon_biomass_rating").and_then(|v| v.as_f64()),
        carbon_confidence: row.get("carbon_biomass_confidence").and_then(|v| v.as_f64()),
        nitrogen_fix_rating: row.get("nitrogen_fixation_rating").and_then(|v| v.as_f64()),
        nitrogen_fix_confidence: row.get("nitrogen_fixation_confidence").and_then(|v| v.as_f64()),
        nitrogen_fix_has_try: row.get("nitrogen_fixation_has_try").and_then(|v| v.as_bool()),
        erosion_rating: row.get("erosion_protection_rating").and_then(|v| v.as_f64()),
        erosion_confidence: row.get("erosion_protection_confidence").and_then(|v| v.as_f64()),
        nutrient_cycling_rating: row.get("nutrient_cycling_rating").and_then(|v| v.as_f64()),
        nutrient_cycling_confidence: row.get("nutrient_cycling_confidence").and_then(|v| v.as_f64()),
        decomposition_rating: row.get("decomposition_rating").and_then(|v| v.as_f64()),
        height_m: row.get("height_m").and_then(|v| v.as_f64()),
        woodiness: row.get("try_woodiness").and_then(|v| v.as_f64()),
        growth_form: row.get("try_growth_form").and_then(|v| v.as_str()).map(|s| s.to_string()),
    }
}

fn calculate_ecosystem_avg(row: &HashMap<String, serde_json::Value>) -> Option<f64> {
    let ratings: Vec<f64> = [
        "carbon_biomass_rating",
        "nitrogen_fixation_rating",
        "erosion_protection_rating",
        "nutrient_cycling_rating",
    ]
    .iter()
    .filter_map(|key| row.get(*key).and_then(|v| v.as_f64()))
    .collect();

    if ratings.is_empty() {
        None
    } else {
        Some(ratings.iter().sum::<f64>() / ratings.len() as f64)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    fn make_test_plant_data() -> HashMap<String, serde_json::Value> {
        let mut data = HashMap::new();
        data.insert("wfo_scientific_name".to_string(), json!("Quercus robur"));
        data.insert("family".to_string(), json!("Fagaceae"));
        data.insert("genus".to_string(), json!("Quercus"));
        data.insert("height_m".to_string(), json!(25.0));
        data.insert("try_growth_form".to_string(), json!("tree"));
        data.insert("try_woodiness".to_string(), json!(1.0));
        data.insert("try_leaf_phenology".to_string(), json!("deciduous"));
        data.insert("EIVE_L".to_string(), json!(6.5));
        data.insert("EIVE_M".to_string(), json!(5.0));
        data.insert("EIVE_T".to_string(), json!(5.5));
        data.insert("EIVE_N".to_string(), json!(5.0));
        data.insert("EIVE_R".to_string(), json!(6.5));
        data.insert("C".to_string(), json!(0.5));
        data.insert("S".to_string(), json!(0.3));
        data.insert("R".to_string(), json!(0.2));
        data.insert("carbon_biomass_rating".to_string(), json!(8.0));
        data.insert("carbon_biomass_confidence".to_string(), json!(0.8));
        data
    }

    #[test]
    fn test_generate_full_page() {
        let generator = EncyclopediaGenerator::new();
        let data = make_test_plant_data();

        let result = generator.generate("wfo-0000292858", &data, None, None);
        assert!(result.is_ok());

        let page = result.unwrap();
        assert!(page.contains("Quercus robur"));
        assert!(page.contains("Fagaceae"));
        assert!(page.contains("Growing Requirements"));
        assert!(page.contains("Maintenance Profile"));
        assert!(page.contains("Ecosystem Services"));
        assert!(page.contains("Biological Interactions"));
    }

    #[test]
    fn test_generate_with_organisms() {
        let generator = EncyclopediaGenerator::new();
        let data = make_test_plant_data();

        let organisms = Some(OrganismCounts {
            pollinators: 15,
            visitors: 10,
            herbivores: 20,
            pathogens: 5,
            predators: 8,
        });

        let fungi = Some(FungalCounts {
            amf: 0,
            emf: 12,
            endophytes: 3,
            mycoparasites: 2,
            entomopathogens: 1,
        });

        let result = generator.generate("wfo-0000292858", &data, organisms, fungi);
        assert!(result.is_ok());

        let page = result.unwrap();
        assert!(page.contains("Pollinator"));
        assert!(page.contains("EMF") || page.contains("Ectomycorrhizae"));
    }
}
