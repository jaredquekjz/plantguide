//! CompactTree - Pure Rust implementation of phylogenetic tree structure
//!
//! This module provides a memory-efficient phylogenetic tree representation
//! for calculating Faith's Phylogenetic Diversity (PD).
//!
//! Translated from CompactTree C++ library (header-only, ~250 lines needed)
//! Original: /home/olier/ellenberg/CompactTree/CompactTree/compact_tree.h

use anyhow::{Context, Result};
use std::collections::{HashMap, HashSet, VecDeque};
use std::io::Read;

/// Special node value representing NULL/invalid node
const NULL_NODE: u32 = u32::MAX;

/// CompactTree - Phylogenetic tree structure
///
/// Uses integer node indices for O(1) access to parent/children/labels/lengths.
/// Memory layout optimized for cache-friendly traversals.
#[derive(Debug, Clone)]
pub struct CompactTree {
    parent: Vec<u32>,           // parent[i] = parent node of node i
    children: Vec<Vec<u32>>,    // children[i] = child nodes of node i
    label: Vec<String>,         // label[i] = taxon label of node i
    length: Vec<f32>,           // length[i] = edge length from parent to node i
    num_leaves: usize,          // Total number of leaf nodes (tips)
    label_to_node: HashMap<String, u32>, // Pre-built label lookup (OPTIMIZATION)
}

impl CompactTree {
    /// Create a new empty CompactTree
    pub fn new() -> Self {
        CompactTree {
            parent: Vec::new(),
            children: Vec::new(),
            label: Vec::new(),
            length: Vec::new(),
            num_leaves: 0,
            label_to_node: HashMap::new(),
        }
    }

    // ========================================================================
    // ACCESSORS (O(1) operations)
    // ========================================================================

    /// Get the parent node of a given node
    #[inline]
    pub fn get_parent(&self, node: u32) -> u32 {
        self.parent[node as usize]
    }

    /// Get the edge length from parent to this node
    #[inline]
    pub fn get_edge_length(&self, node: u32) -> f32 {
        self.length[node as usize]
    }

    /// Check if a node is a leaf (has no children)
    #[inline]
    pub fn is_leaf(&self, node: u32) -> bool {
        self.children[node as usize].is_empty()
    }

    /// Get the total number of nodes in the tree
    #[inline]
    pub fn get_num_nodes(&self) -> usize {
        self.parent.len()
    }

    /// Get the label (taxon name) of a node
    #[inline]
    pub fn get_label(&self, node: u32) -> &str {
        &self.label[node as usize]
    }

    /// Get the number of leaf nodes (tips)
    #[inline]
    pub fn num_leaves(&self) -> usize {
        self.num_leaves
    }

    // ========================================================================
    // TREE CONSTRUCTION
    // ========================================================================

    /// Build CompactTree from raw node data
    ///
    /// This is a temporary constructor that takes pre-parsed tree data.
    /// Later we can add Newick parser to load directly from .nwk files.
    pub fn from_raw(
        parent: Vec<u32>,
        children: Vec<Vec<u32>>,
        label: Vec<String>,
        length: Vec<f32>,
    ) -> Result<Self> {
        let num_nodes = parent.len();

        // Validate consistency
        if children.len() != num_nodes || label.len() != num_nodes || length.len() != num_nodes {
            anyhow::bail!("Inconsistent node data sizes");
        }

        // Count leaves
        let num_leaves = children.iter().filter(|c| c.is_empty()).count();

        // Build label -> node lookup map (OPTIMIZATION)
        let mut label_to_node = HashMap::with_capacity(num_leaves);
        for (idx, node_children) in children.iter().enumerate() {
            if node_children.is_empty() {
                // This is a leaf node
                label_to_node.insert(label[idx].clone(), idx as u32);
            }
        }

        Ok(CompactTree {
            parent,
            children,
            label,
            length,
            num_leaves,
            label_to_node,
        })
    }

    /// Load CompactTree from binary file
    ///
    /// Binary format (generated by dump_tree_structure.cpp):
    /// - u32: num_nodes
    /// - u32: num_leaves
    /// For each node (0..num_nodes):
    ///   - u32: parent index (0xFFFFFFFF = NULL)
    ///   - u32: num_children
    ///   - u32[num_children]: child indices
    ///   - u32: label_len
    ///   - char[label_len]: label string
    ///   - f32: edge_length
    pub fn from_binary(path: &str) -> Result<Self> {
        use std::fs::File;
        use std::io::BufReader;

        let file = File::open(path)
            .with_context(|| format!("Failed to open tree binary: {}", path))?;
        let mut reader = BufReader::new(file);

        // Read header
        let num_nodes = Self::read_u32(&mut reader)?;
        let num_leaves_file = Self::read_u32(&mut reader)?;

        // Pre-allocate vectors
        let mut parent = Vec::with_capacity(num_nodes as usize);
        let mut children = Vec::with_capacity(num_nodes as usize);
        let mut label = Vec::with_capacity(num_nodes as usize);
        let mut length = Vec::with_capacity(num_nodes as usize);

        // Read each node
        for _ in 0..num_nodes {
            // Parent
            parent.push(Self::read_u32(&mut reader)?);

            // Children
            let num_children = Self::read_u32(&mut reader)?;
            let mut node_children = Vec::with_capacity(num_children as usize);
            for _ in 0..num_children {
                node_children.push(Self::read_u32(&mut reader)?);
            }
            children.push(node_children);

            // Label
            label.push(Self::read_string(&mut reader)?);

            // Edge length
            length.push(Self::read_f32(&mut reader)?);
        }

        // Build label -> node lookup map (OPTIMIZATION)
        let mut label_to_node = HashMap::with_capacity(num_leaves_file as usize);
        for (idx, node_children) in children.iter().enumerate() {
            if node_children.is_empty() {
                // This is a leaf node
                label_to_node.insert(label[idx].clone(), idx as u32);
            }
        }

        Ok(CompactTree {
            parent,
            children,
            label,
            length,
            num_leaves: num_leaves_file as usize,
            label_to_node,
        })
    }

    // Helper functions for binary reading
    fn read_u32<R: Read>(reader: &mut R) -> Result<u32> {
        let mut buf = [0u8; 4];
        reader.read_exact(&mut buf)?;
        Ok(u32::from_le_bytes(buf))
    }

    fn read_f32<R: Read>(reader: &mut R) -> Result<f32> {
        let mut buf = [0u8; 4];
        reader.read_exact(&mut buf)?;
        Ok(f32::from_le_bytes(buf))
    }

    fn read_string<R: Read>(reader: &mut R) -> Result<String> {
        let len = Self::read_u32(reader)? as usize;
        let mut buf = vec![0u8; len];
        reader.read_exact(&mut buf)?;
        Ok(String::from_utf8(buf)?)
    }

    // ========================================================================
    // TREE QUERIES
    // ========================================================================

    /// Find node indices by labels (taxon names)
    ///
    /// Returns a vector of node indices matching the given labels.
    /// Only returns leaf nodes (tips).
    ///
    /// OPTIMIZATION: Uses pre-built label_to_node map (built once at load time)
    pub fn find_leaf_nodes(&self, labels: &[String]) -> Vec<u32> {
        // Use pre-built map for O(1) lookup (no rebuilding!)
        labels
            .iter()
            .filter_map(|label| self.label_to_node.get(label).copied())
            .collect()
    }

    /// Find Most Recent Common Ancestor (MRCA) of a set of leaf nodes
    ///
    /// Algorithm: BFS from all leaves, counting visits to each node.
    /// First node visited N times (where N = leaf count) is the MRCA.
    ///
    /// C++ reference: compact_tree.h lines 520-537
    /// OPTIMIZATION: Uses Vec<u32> instead of HashMap for visit counting
    pub fn find_mrca(&self, leaf_nodes: &HashSet<u32>) -> Result<u32> {
        if leaf_nodes.is_empty() {
            anyhow::bail!("Cannot find MRCA of empty leaf set");
        }
        if leaf_nodes.len() == 1 {
            return Ok(*leaf_nodes.iter().next().unwrap());
        }

        // BFS queue: start with all leaf nodes
        let mut queue: VecDeque<u32> = leaf_nodes.iter().copied().collect();

        // OPTIMIZATION: Use Vec<u32> instead of HashMap (direct array access)
        let mut visit_count = vec![0u32; self.get_num_nodes()];
        let total_leaves = leaf_nodes.len() as u32;

        while let Some(node) = queue.pop_front() {
            // Increment visit count (O(1) array access)
            visit_count[node as usize] += 1;

            // If this node has been visited by all leaves, it's the MRCA
            if visit_count[node as usize] == total_leaves {
                return Ok(node);
            }

            // Add parent to queue
            let parent = self.get_parent(node);
            if parent != NULL_NODE {
                queue.push_back(parent);
            }
        }

        anyhow::bail!("No MRCA found (disconnected tree?)")
    }

    /// Calculate Faith's Phylogenetic Diversity (PD) for a set of leaf nodes
    ///
    /// Faith's PD = sum of unique branch lengths from tips to their MRCA
    ///
    /// Algorithm:
    /// 1. Find MRCA of all leaf nodes
    /// 2. Walk from each leaf to MRCA, summing unique branch lengths
    /// 3. Use visited array for O(1) duplicate detection
    ///
    /// C++ reference: calculate_faiths_pd_optimized.cpp lines 36-71
    /// OPTIMIZATION: Uses Vec<u8> instead of Vec<bool> (avoids bit-packing overhead)
    pub fn calculate_faiths_pd(&self, leaf_nodes: &[u32]) -> f64 {
        // Edge case: need at least 2 species
        if leaf_nodes.len() < 2 {
            return 0.0;
        }

        // Find MRCA
        let leaf_set: HashSet<u32> = leaf_nodes.iter().copied().collect();
        let mrca = match self.find_mrca(&leaf_set) {
            Ok(m) => m,
            Err(_) => return 0.0,
        };

        // OPTIMIZATION: Use Vec<u8> instead of Vec<bool>
        // Vec<bool> uses bit-packing which is slower than direct u8 access
        // Matches C++ vector<uint8_t> optimization
        let mut visited = vec![0u8; self.get_num_nodes()];
        let mut total_pd = 0.0_f64;

        // Walk from each leaf to MRCA, summing unique branch lengths
        for &leaf in leaf_nodes {
            let mut current = leaf;
            while current != mrca {
                if visited[current as usize] == 0 {
                    total_pd += self.get_edge_length(current) as f64;
                    visited[current as usize] = 1;
                }
                current = self.get_parent(current);
            }
        }

        total_pd
    }

    /// Calculate Faith's PD given taxon labels (convenience wrapper)
    ///
    /// Finds leaf nodes by labels, then calculates PD.
    pub fn calculate_faiths_pd_by_labels(&self, labels: &[String]) -> f64 {
        let leaf_nodes = self.find_leaf_nodes(labels);
        self.calculate_faiths_pd(&leaf_nodes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Helper function to create a simple test tree
    ///
    /// Tree structure:
    ///       4 (root)
    ///      / \
    ///     2   3
    ///    / \
    ///   0   1
    ///
    /// Leaves: A (0), B (1), C (3)
    /// Internal: node 2, node 4
    fn create_test_tree() -> CompactTree {
        let parent = vec![
            2,         // 0 (A) -> 2
            2,         // 1 (B) -> 2
            4,         // 2 -> 4
            4,         // 3 (C) -> 4
            NULL_NODE, // 4 (root) -> NULL
        ];

        let children = vec![
            vec![],       // 0 (A) - leaf
            vec![],       // 1 (B) - leaf
            vec![0, 1],   // 2 - internal
            vec![],       // 3 (C) - leaf
            vec![2, 3],   // 4 - root
        ];

        let label = vec![
            "A".to_string(),
            "B".to_string(),
            "node2".to_string(),
            "C".to_string(),
            "root".to_string(),
        ];

        let length = vec![
            1.0,  // A -> node2 (edge length 1.0)
            2.0,  // B -> node2 (edge length 2.0)
            3.0,  // node2 -> root (edge length 3.0)
            4.0,  // C -> root (edge length 4.0)
            0.0,  // root (no parent edge)
        ];

        CompactTree::from_raw(parent, children, label, length).unwrap()
    }

    #[test]
    fn test_accessors() {
        let tree = create_test_tree();

        assert_eq!(tree.get_num_nodes(), 5);
        assert_eq!(tree.num_leaves(), 3);

        assert_eq!(tree.get_parent(0), 2);
        assert_eq!(tree.get_parent(1), 2);
        assert_eq!(tree.get_parent(2), 4);
        assert_eq!(tree.get_parent(3), 4);
        assert_eq!(tree.get_parent(4), NULL_NODE);

        assert_eq!(tree.get_edge_length(0), 1.0);
        assert_eq!(tree.get_edge_length(1), 2.0);
        assert_eq!(tree.get_edge_length(2), 3.0);

        assert!(tree.is_leaf(0));
        assert!(tree.is_leaf(1));
        assert!(!tree.is_leaf(2));
        assert!(tree.is_leaf(3));
        assert!(!tree.is_leaf(4));

        assert_eq!(tree.get_label(0), "A");
        assert_eq!(tree.get_label(3), "C");
    }

    #[test]
    fn test_find_leaf_nodes() {
        let tree = create_test_tree();

        let labels = vec!["A".to_string(), "C".to_string()];
        let nodes = tree.find_leaf_nodes(&labels);

        assert_eq!(nodes.len(), 2);
        assert!(nodes.contains(&0));
        assert!(nodes.contains(&3));
    }

    #[test]
    fn test_find_mrca() {
        let tree = create_test_tree();

        // MRCA of A and B should be node 2
        let leaves: HashSet<u32> = vec![0, 1].into_iter().collect();
        let mrca = tree.find_mrca(&leaves).unwrap();
        assert_eq!(mrca, 2);

        // MRCA of A and C should be root (node 4)
        let leaves: HashSet<u32> = vec![0, 3].into_iter().collect();
        let mrca = tree.find_mrca(&leaves).unwrap();
        assert_eq!(mrca, 4);

        // MRCA of all three should be root
        let leaves: HashSet<u32> = vec![0, 1, 3].into_iter().collect();
        let mrca = tree.find_mrca(&leaves).unwrap();
        assert_eq!(mrca, 4);
    }

    #[test]
    fn test_calculate_faiths_pd() {
        let tree = create_test_tree();

        // PD of A and B: edge 0->2 (1.0) + edge 1->2 (2.0) = 3.0
        let pd = tree.calculate_faiths_pd(&vec![0, 1]);
        assert!((pd - 3.0).abs() < 1e-6);

        // PD of A and C:
        // - A->2 (1.0) + 2->4 (3.0) + C->4 (4.0) = 8.0
        let pd = tree.calculate_faiths_pd(&vec![0, 3]);
        assert!((pd - 8.0).abs() < 1e-6);

        // PD of all three:
        // - A->2 (1.0) + B->2 (2.0) + 2->4 (3.0) + C->4 (4.0) = 10.0
        let pd = tree.calculate_faiths_pd(&vec![0, 1, 3]);
        assert!((pd - 10.0).abs() < 1e-6);

        // Edge case: single species
        let pd = tree.calculate_faiths_pd(&vec![0]);
        assert_eq!(pd, 0.0);
    }

    #[test]
    fn test_calculate_faiths_pd_by_labels() {
        let tree = create_test_tree();

        let labels = vec!["A".to_string(), "B".to_string()];
        let pd = tree.calculate_faiths_pd_by_labels(&labels);
        assert!((pd - 3.0).abs() < 1e-6);
    }
}
